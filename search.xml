<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java内存分配介绍</title>
      <link href="/codeYzl/codeYzl.github.io/2022/09/05/java/"/>
      <url>/codeYzl/codeYzl.github.io/2022/09/05/java/</url>
      
        <content type="html"><![CDATA[<h1 id="Java内存分配介绍"><a href="#Java内存分配介绍" class="headerlink" title="Java内存分配介绍"></a>Java内存分配介绍</h1><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>方法运行时所进入的内存，变量也是在这里</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>new出来的东西会在这块内存中开辟空间并产生地址</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>字节码文件加载时进入的内存</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021CCPC广州 C.necklace</title>
      <link href="/codeYzl/codeYzl.github.io/2022/09/05/ccpcGZ/"/>
      <url>/codeYzl/codeYzl.github.io/2022/09/05/ccpcGZ/</url>
      
        <content type="html"><![CDATA[<h1 id="C-necklace"><a href="#C-necklace" class="headerlink" title="C.necklace"></a>C.necklace</h1><p>题目链接：<a href="https://codeforces.com/gym/103415/problem/C">Problem - C - Codeforces</a></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>一串项链有1~n个节点，n和1相连（形成环），其中m个节点是Bob喜欢的，现在给出这m个节点的位置，要求把项链分割成m段，使每段都至少有一个Bob喜欢的节点。求最大段长度最小是多少？</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>最大值最小我们可以通过二分来求，但如何通过check函数来二分是本题的难点，一般在check函数里都有用到贪心思想，因为只要最优情况满足条件那么当前的mid即为合法答案</p><p>可以想到mid是最大区间长度，而对于一个区间的长度len，在满足小于等于mid和右端点小于下一个Bob喜欢的节点的前提下，右端点要尽可能逼近  下一个特殊节点</p><p><img src="https://s3.bmp.ovh/imgs/2022/09/05/b29718811da38afc.png"></p><p>所以确定了第一个区间的左端点，那么整个区间的划分情况都可以确定了，但是由于是环形，这样使得枚举左端点的时间复杂度很高，而且数据范围很大所以我们应该贪心的优化问题</p><h3 id="贪心优化"><a href="#贪心优化" class="headerlink" title="贪心优化"></a>贪心优化</h3><p>如果我们确定了左端点l，然后得到第一次贪心下的右端点，那么 r-l+1  是在不超过下一个特殊节点下取到的len,</p><p>而且这个len一定小于等于mid，但是这样是不是没有把利益最大化？因为我们明明可以取到mid，只要不超过mid就行，但是在限制下，len取小了，但是换一种思路，我们是不是可以把l前移，在不超过前一个特殊点的情况下前移（同时len也不超过mid），那么这样是不是利益最大化了，因为对于前一段来说，如果仅仅在第一个贪心的思想下，mid满足不了，那么就return false了，但实际上后一段可以为它多“吃”一段，那么可能就会满足条件了</p><p><img src="https://s3.bmp.ovh/imgs/2022/09/05/9fbbb2a2299cd798.png"></p><h3 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a>思路总结</h3><p><img src="https://s3.bmp.ovh/imgs/2022/09/05/f5e6a1078fb785b8.png"></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">LL a[N];</span><br><span class="line">LL n,m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(LL mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL minv = <span class="number">1e18</span>;</span><br><span class="line">    LL p = a[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">    LL detla = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>;i &lt;= m - <span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p + mid &lt; a[i]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//无法到达右端点</span></span><br><span class="line">        LL d = p + mid - a[i+<span class="number">1</span>] + <span class="number">1</span>;<span class="comment">//可以多利用的长度</span></span><br><span class="line">        <span class="keyword">if</span>(d &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = a[i+<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(detla &lt;= minv)<span class="comment">//只有小于到前一个特殊点的距离才可以</span></span><br><span class="line">            &#123;</span><br><span class="line">                detla += <span class="built_in">min</span>(d,minv - detla);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p = p + mid;<span class="comment">//否则直接后移最大长度</span></span><br><span class="line">        minv = <span class="built_in">min</span>(minv,p-a[i]+detla);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p + mid + detla &gt;= n &amp;&amp; (p + mid + detla) % n &gt;= a[<span class="number">1</span>] - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    LL l = <span class="number">0</span>,r = n;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        LL mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路及图片参考： @gxunWang</p>]]></content>
      
      
      <categories>
          
          <category> CCPC广州 </category>
          
          <category> 网络选拔赛训练赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
