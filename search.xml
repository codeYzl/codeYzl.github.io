<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>树形动态规划(一)</title>
      <link href="/archives/a0ab2bd9.html"/>
      <url>/archives/a0ab2bd9.html</url>
      
        <content type="html"><![CDATA[<h1 id="树形动态规划入门（一）树上背包"><a href="#树形动态规划入门（一）树上背包" class="headerlink" title="树形动态规划入门（一）树上背包"></a>树形动态规划入门（一）树上背包</h1><h2 id="例题（1）"><a href="#例题（1）" class="headerlink" title="例题（1）"></a>例题（1）</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个 n(1≤n≤2000)n(1≤n≤2000) 个点的有根树，其中1号点为根。每个点有一个权值ai(−105≤ai≤105)，权值可能是负数。</p><p>你需要回答 q(1≤q≤105) 个询问，在 u 的子树中，选择一个大小恰好为 m(1≤m≤n) 的包含 u 点的连通块，最大的权值和。保证 m 不会超过 u 的子树大小。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于每个点，都可以在每个子树里选择合并任意节点，但是要在不超过m个节点的限制，这样是不是很像背包问题，对的我们将背包的思想代入，体积相当于节点个数，价值相当于权值</p><p>可以用f[i][j]表示前i个节点选了j个节点的权值和，那么对于当前节点我们可以考虑将它的某些子节点合并成一个连通块，</p><p>由于n的数据范围只有2000，我们可以考虑枚举，将问题分为两类，一类是sz[u]，表示dfs过的子树里，一类是sz[v]，表示目前要考虑合并的子节点，那么合并的个数就是sz[u]的子集和sz[v]的子集。</p><p>我们这里指的合并并不是要真的合并，而是用一个tmp数组，下标表示已合并的个数，存储权值的最大值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2100</span>, M = N, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> w[N], f[N][N], sz[N];</span><br><span class="line"><span class="type">int</span> tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">0</span>;</span><br><span class="line">    f[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt;= sz[u] + sz[j]; v ++ ) tmp[v] = -INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= sz[u]; k ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt;= sz[j]; v ++ )</span><br><span class="line">                tmp[k + v] = <span class="built_in">max</span>(tmp[k + v], f[u][k] + f[j][v]);</span><br><span class="line">        sz[u] += sz[j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt;= sz[u]; v ++ ) f[u][v] = tmp[v];</span><br><span class="line">        <span class="comment">//if (u == 2) cout &lt;&lt; f[u][2] &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    sz[u] += <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//if (u == 4) cout &lt;&lt; sz[u] &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = sz[u]; i &gt;= <span class="number">1</span>; i -- ) f[u][i] = f[u][i - <span class="number">1</span>] + w[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="built_in">add</span>(x, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; f[1][2] &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="comment">//cout &lt;&lt;x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[x][y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-（2）树上背包（二）"><a href="#例题-（2）树上背包（二）" class="headerlink" title="例题 （2）树上背包（二）"></a>例题 （2）树上背包（二）</h2><blockquote><p>给你一个n(1≤n≤50000) 个点的有根树，其中1号点为根。每个点有一个权值ai(−105≤ai≤105)，权值可能是负数。</p><p>你需要回答 q(1≤q≤105) 个询问，在 u的子树中，选择一个大小恰好为 m(1≤m≤100) 的包含 u 点的连通块，最大的权值和。保证 m 不会超过 u 的子树大小。</p></blockquote><p>这题与例题一的不同是n的范围变大了，但是因为给了m的范围，所以第二维的范围只要求[1,100]的最大值即可</p>]]></content>
      
      
      <categories>
          
          <category> 树形动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树上问题 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 树形DP </tag>
            
            <tag> 树上背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存分配介绍</title>
      <link href="/archives/9a7c0487.html"/>
      <url>/archives/9a7c0487.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java内存分配介绍"><a href="#Java内存分配介绍" class="headerlink" title="Java内存分配介绍"></a>Java内存分配介绍</h1><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>方法运行时所进入的内存，变量也是在这里</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>new出来的东西会在这块内存中开辟空间并产生地址</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>字节码文件加载时进入的内存</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021CCPC广州 C.necklace</title>
      <link href="/archives/12536c1f.html"/>
      <url>/archives/12536c1f.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-necklace"><a href="#C-necklace" class="headerlink" title="C.necklace"></a>C.necklace</h1><p>题目链接：<a href="https://codeforces.com/gym/103415/problem/C">Problem - C - Codeforces</a></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>一串项链有1~n个节点，n和1相连（形成环），其中m个节点是Bob喜欢的，现在给出这m个节点的位置，要求把项链分割成m段，使每段都至少有一个Bob喜欢的节点。求最大段长度最小是多少？</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>最大值最小我们可以通过二分来求，但如何通过check函数来二分是本题的难点，一般在check函数里都有用到贪心思想，因为只要最优情况满足条件那么当前的mid即为合法答案</p><p>可以想到mid是最大区间长度，而对于一个区间的长度len，在满足小于等于mid和右端点小于下一个Bob喜欢的节点的前提下，右端点要尽可能逼近  下一个特殊节点</p><p><img src="https://s3.bmp.ovh/imgs/2022/09/05/b29718811da38afc.png"></p><p>所以确定了第一个区间的左端点，那么整个区间的划分情况都可以确定了，但是由于是环形，这样使得枚举左端点的时间复杂度很高，而且数据范围很大所以我们应该贪心的优化问题</p><h3 id="贪心优化"><a href="#贪心优化" class="headerlink" title="贪心优化"></a>贪心优化</h3><p>如果我们确定了左端点l，然后得到第一次贪心下的右端点，那么 r-l+1  是在不超过下一个特殊节点下取到的len,</p><p>而且这个len一定小于等于mid，但是这样是不是没有把利益最大化？因为我们明明可以取到mid，只要不超过mid就行，但是在限制下，len取小了，但是换一种思路，我们是不是可以把l前移，在不超过前一个特殊点的情况下前移（同时len也不超过mid），那么这样是不是利益最大化了，因为对于前一段来说，如果仅仅在第一个贪心的思想下，mid满足不了，那么就return false了，但实际上后一段可以为它多“吃”一段，那么可能就会满足条件了</p><p><img src="https://s3.bmp.ovh/imgs/2022/09/05/9fbbb2a2299cd798.png"></p><h3 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a>思路总结</h3><p><img src="https://s3.bmp.ovh/imgs/2022/09/05/f5e6a1078fb785b8.png"></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">LL a[N];</span><br><span class="line">LL n,m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(LL mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL minv = <span class="number">1e18</span>;</span><br><span class="line">    LL p = a[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">    LL detla = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>;i &lt;= m - <span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p + mid &lt; a[i]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//无法到达右端点</span></span><br><span class="line">        LL d = p + mid - a[i+<span class="number">1</span>] + <span class="number">1</span>;<span class="comment">//可以多利用的长度</span></span><br><span class="line">        <span class="keyword">if</span>(d &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = a[i+<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(detla &lt;= minv)<span class="comment">//只有小于到前一个特殊点的距离才可以</span></span><br><span class="line">            &#123;</span><br><span class="line">                detla += <span class="built_in">min</span>(d,minv - detla);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p = p + mid;<span class="comment">//否则直接后移最大长度</span></span><br><span class="line">        minv = <span class="built_in">min</span>(minv,p-a[i]+detla);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p + mid + detla &gt;= n &amp;&amp; (p + mid + detla) % n &gt;= a[<span class="number">1</span>] - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    LL l = <span class="number">0</span>,r = n;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        LL mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路及图片参考： @gxunWang</p>]]></content>
      
      
      <categories>
          
          <category> CCPC广州 </category>
          
          <category> 网络选拔赛训练赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
