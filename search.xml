<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>精通Shell之路</title>
      <link href="/archives/fcf4a860.html"/>
      <url>/archives/fcf4a860.html</url>
      
        <content type="html"><![CDATA[<h3 id="Shell常用通配符"><a href="#Shell常用通配符" class="headerlink" title="Shell常用通配符"></a>Shell常用通配符</h3><p><img src="https://s3.uuu.ovh/imgs/2022/11/24/35b77959f4227213.png"></p><h3 id="有趣的图形命令"><a href="#有趣的图形命令" class="headerlink" title="有趣的图形命令"></a>有趣的图形命令</h3><p>可以输出图形命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install sysvbanner</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带你玩转vim</title>
      <link href="/archives/3e5ccac0.html"/>
      <url>/archives/3e5ccac0.html</url>
      
        <content type="html"><![CDATA[<h1 id="带你玩转vim"><a href="#带你玩转vim" class="headerlink" title="带你玩转vim"></a>带你玩转vim</h1><p><img src="https://labfile.oss.aliyuncs.com/courses/2840/vi-keyboard.gif"></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">u: #撤销</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Ctrl + u #取消撤销</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">v #选中文本</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">d #删除选中文本</span><br></pre></td></tr></table></figure><blockquote><p>(1) i：进入编辑模式<br>   (2) ESC：进入一般命令模式<br>   (3) h 或 左箭头键：光标向左移动一个字符<br>   (4) j 或 向下箭头：光标向下移动一个字符<br>   (5) k 或 向上箭头：光标向上移动一个字符<br>   (6) l 或 向右箭头：光标向右移动一个字符<br>   (7) n<Space>：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符<br>   (8) 0 或 功能键[Home]：光标移动到本行开头<br>   (9) $ 或 功能键[End]：光标移动到本行末尾<br>   (10) G：光标移动到最后一行<br>   (11) :n 或 nG：n为数字，光标移动到第n行<br>   (12) gg：光标移动到第一行，相当于1G<br>   (13) n<Enter>：n为数字，光标向下移动n行<br>   (14) &#x2F;word：向光标之下寻找第一个值为word的字符串。<br>   (15) ?word：向光标之上寻找第一个值为word的字符串。<br>   (16) n：重复前一个查找操作<br>   (17) N：反向重复前一个查找操作<br>   (18) :n1,n2s&#x2F;word1&#x2F;word2&#x2F;g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2<br>   (19) :1,$s&#x2F;word1&#x2F;word2&#x2F;g：将全文的word1替换为word2<br>   (20) :1,$s&#x2F;word1&#x2F;word2&#x2F;gc：将全文的word1替换为word2，且在替换前要求用户确认。<br>   (21) v：选中文本<br>   (22) d：删除选中的文本<br>   (23) dd: 删除当前行<br>   (24) y：复制选中的文本<br>   (25) yy: 复制当前行<br>   (26) p: 将复制的数据在光标的下一行&#x2F;下一个位置粘贴<br>   (27) u：撤销<br>   (28) Ctrl + r：取消撤销<br>   (29) 大于号 &gt;：将选中的文本整体向右缩进一次<br>   (30) 小于号 &lt;：将选中的文本整体向左缩进一次<br>   (31) :w 保存<br>   (32) :w! 强制保存<br>   (33) :q 退出<br>   (34) :q! 强制退出<br>   (35) :wq 保存并退出<br>   (36) :set paste 设置成粘贴模式，取消代码自动缩进<br>   (37) :set nopaste 取消粘贴模式，开启代码自动缩进<br>   (38) :set nu 显示行号<br>   (39) :set nonu 隐藏行号<br>   (40) gg&#x3D;G：将全文代码格式化<br>   (41) :noh 关闭查找关键词高亮<br>   (42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/archives/0.html"/>
      <url>/archives/0.html</url>
      
        <content type="html"><![CDATA[<h2 id="git与github-的连接"><a href="#git与github-的连接" class="headerlink" title="git与github 的连接"></a>git与github 的连接</h2><h3 id="使用SSH拉取远程仓库"><a href="#使用SSH拉取远程仓库" class="headerlink" title="使用SSH拉取远程仓库"></a>使用SSH拉取远程仓库</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/archives/0.html"/>
      <url>/archives/0.html</url>
      
        <content type="html"><![CDATA[<h3 id="树状数组求逆序对"><a href="#树状数组求逆序对" class="headerlink" title="树状数组求逆序对"></a>树状数组求逆序对</h3><p><strong>方法： 离散化 + 树状数组求和</strong></p><blockquote><p>b数组表示 下标 ，按大小排好序后的b数组的b[i] 就表示 第i大的数在原数组的位置是b[i]</p><p>如何求个数：对于b[i] 将其加入树状数组，对（ b[i]-1 ） 求和的值代表着前b[i]-1的位置有多少个比其大的数就是逆序对</p></blockquote><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> b[N],a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line">ll tr[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[x] == a[y]) <span class="keyword">return</span> x &gt; y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a[x] &gt; a[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x  &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,ll c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x;i &lt;= n;i += <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">        tr[i] += c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x;i;i -= <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">        ans += tr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) b[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="built_in">modify</span>(b[i],<span class="number">1</span>);</span><br><span class="line">        ans += <span class="built_in">query</span>(b[i] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间更新-单点查询"><a href="#区间更新-单点查询" class="headerlink" title="区间更新 单点查询"></a>区间更新 单点查询</h3><p><a href="https://vjudge.net/problem/HDU-1556">https://vjudge.net/problem/HDU-1556</a></p><blockquote><p>Hint：用一个差分数组再加一个树状数组维护，对于<strong>单点询问</strong>就可以转换成求差分数组的前缀和 ，对于<strong>区间修改</strong>可以转换成树状数组的单点修改</p></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x;i;i -= <span class="built_in">lowbit</span>(i)) res += c[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x;i &lt;= n;i += <span class="built_in">lowbit</span>(i)) c[i] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n &amp;&amp; n)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span> c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a,b;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="built_in">add</span>(a,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">add</span>(b+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">sum</span>(i)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区间更新 区间查询</p><blockquote><p> Hint:差分数组的前缀和就是区间求和</p><p>((x+1） * di )- (i*di)</p></blockquote><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> c1[N],c2[N],a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    ll val = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x;i &lt;= n;i += <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">        c1[i] += c;</span><br><span class="line">        c2[i] += c * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    ll val = x;</span><br><span class="line">    ll tmp1 = <span class="number">0</span>;</span><br><span class="line">    ll tmp2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x;i;i -= <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">        tmp1 += c1[i];</span><br><span class="line">        tmp2 += c2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (val + <span class="number">1</span>) * tmp1 - tmp2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="built_in">add</span>(i,a[i] - a[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="type">int</span> a1,b1;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= q;i++)&#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c%d%d&quot;</span>,&amp;op,&amp;a1,&amp;b1);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="built_in">add</span>(a1,x);</span><br><span class="line">            <span class="built_in">add</span>(b1,-x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           </span><br><span class="line">            cout&lt;&lt;<span class="built_in">query</span>(b1) - <span class="built_in">query</span>(a1<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round#826(Div. 3)</title>
      <link href="/archives/c7d02bc0.html"/>
      <url>/archives/c7d02bc0.html</url>
      
        <content type="html"><![CDATA[<p>比赛链接： <a href="https://codeforces.com/contest/1741">Codeforces Round#826(Div. 3)</a></p><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><ul><li>题意 ： 判断两个尺码谁大谁小，严格按照L&gt;M&gt;S，对于L而言，X越多越大。对于S而言，X越多越小。</li><li>tag:模拟<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> b=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">   <span class="comment">//cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(a.find(<span class="string">&quot;L&quot;</span>) != a.npos &amp;&amp; b.find(<span class="string">&quot;L&quot;</span>) == b.npos)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;&gt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a.find(<span class="string">&quot;L&quot;</span>) == a.npos &amp;&amp; b.find(<span class="string">&quot;L&quot;</span>) != b.npos)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;&lt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a.find(<span class="string">&quot;S&quot;</span>) != a.npos &amp;&amp; b.find(<span class="string">&quot;S&quot;</span>) == b.npos)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;&lt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a.find(<span class="string">&quot;S&quot;</span>) ==a.npos &amp;&amp; b.find(<span class="string">&quot;S&quot;</span>) != b.npos)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;&gt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a.find(<span class="string">&quot;S&quot;</span>) != a.npos &amp;&amp; b.find(<span class="string">&quot;S&quot;</span>) != b.npos)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.size() &lt; b.size()) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;&gt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.size() &gt; b.size())<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;&lt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a.find(<span class="string">&quot;L&quot;</span>)!=a.npos &amp;&amp; b.find(<span class="string">&quot;L&quot;</span>) != b.npos)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.size() &lt; b.size()) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;&lt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.size() &gt; b.size())<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;&gt;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="string">&quot;M&quot;</span> &amp;&amp; b== <span class="string">&quot;M&quot;</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="B-Funny-Permutation"><a href="#B-Funny-Permutation" class="headerlink" title="B Funny Permutation"></a>B Funny Permutation</h1><p>tag ： <strong>简单构造</strong></p><p>题意： 给出给出长度n，返回任意符合以下要求的数组：1.不可以存在a[i]&#x3D;i；2.对于每一个元素，只要有一个与他相邻的元素与他在值上也相邻。如果不存在，直接返回-1.<br>做法： 如果是偶数，那么可以将1~n两两一组交换即可<br>如果是奇数，只需要把最大的两个数放在前面即可，后面顺序输出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1010000</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>  i = <span class="number">1</span>;i &lt;= n;i++) a[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>  i = <span class="number">1</span>;i &lt;= n<span class="number">-1</span>;i+=<span class="number">2</span>) swap(a[i],a[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n <span class="number">-2</span>;i++) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Minimize-the-Thickness"><a href="#C-Minimize-the-Thickness" class="headerlink" title="C. Minimize the Thickness"></a>C. Minimize the Thickness</h1><p><em>题意</em> ：一个长度为n的数组，将其分成连续不重合的几部分，各部分数字之和相等。定义thickness为分完之后最长的那一部分的长度。求得出一个数组可能的thickness的最小值。</p><blockquote><p>思路分析； 由于n只有2000的数量级所以我们可以暴力枚举<br>每一部分都是sum的因子，所以我们可以将其分解因式后暴力</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2020</span>];</span><br><span class="line"><span class="type">int</span> n,sum;</span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> sum)</span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>,len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        cnt += a[i],len++;</span><br><span class="line">        <span class="keyword">if</span>(sum == cnt)&#123;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            ans = max(ans,len);</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; cnt)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cin</span>&gt;&gt;a[i],sum += a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= sum / i;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> k = check(i);</span><br><span class="line">            <span class="keyword">if</span>(k != <span class="number">-1</span>) ans = min(ans,k);</span><br><span class="line">            k = check(sum / i);</span><br><span class="line">            <span class="keyword">if</span>(k != <span class="number">-1</span>) ans = min(ans,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Masha-and-a-Beautiful-Tree"><a href="#D-Masha-and-a-Beautiful-Tree" class="headerlink" title="D. Masha and a Beautiful Tree"></a>D. Masha and a Beautiful Tree</h1><p><strong>题目大意</strong>：<br> 一棵完全二叉树，拥有n个叶子结点，且叶子节点的值为1-n的任意排列。现在存在一个操作，选定一个节点，交换其左右子树。问将叶子结点的权值修改成从左到右递增最少需要多少次操作。<br> <strong>题目分析</strong>：<br> 从两个输出结果是-1的样例可以看出来，如果两个区间中，一个区间的最小值比另一个区间最大值的要小的话，无论怎么还都无法满足需求。也就是有解的条件为：区间最小值大于另一个区间的最大值。<br>每次往下走之后观察是否有解（扫一下最大值和最小值即可）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],s[N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[l] &gt; a[r]) ans ++ ;</span><br><span class="line">    <span class="type">int</span> mn1 = INF, mx1 = <span class="number">0</span>, mn2 = INF, mx2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= mid; i ++ ) </span><br><span class="line">        mn1 = min(mn1, a[i]), mx1 = max(mx1, a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i ++ )</span><br><span class="line">        mn2 = min(mn2, a[i]), mx2 = max(mx2, a[i]);</span><br><span class="line">    <span class="keyword">if</span>(a[l] &gt; a[r]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mn1 &lt; mx2) ans = INF;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx1 &gt; mn2) ans = INF;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(l, mid), dfs(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">if</span>(ans &gt;= INF ) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="E-Sending-a-Sequence-Over-the-Network"><a href="#E-Sending-a-Sequence-Over-the-Network" class="headerlink" title="E. Sending a Sequence Over the Network"></a>E. Sending a Sequence Over the Network</h1><p>dp<br><strong>题目大意</strong><br>给定几段序列拼接在一起，其中它们的长度被放在序列的左边或右边，问是否合法<br><strong>题目分析</strong><br>dp[i]表示1~i的序列是合法的，我们只分析i是表示序列长度的点.<br>如果它在线段的左边，只有dp[i−1]&#x3D;true，它才有意义。然后dp (i + b[i]]&#x3D; true。</p><p>如果它在线段的右侧，那么如果dp[i−b[i]−1]&#x3D;true，则dp[i]&#x3D;true。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> forn(i, n) for (int i = 0; i &lt; int(n); i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sz(v) (int)v.size()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(v) v.begin(),v.end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">a</span><span class="params">(n+<span class="number">1</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; <span class="title function_">dp</span><span class="params">(n+<span class="number">1</span>, <span class="literal">false</span>)</span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + a[i] &lt;= n &amp;&amp; dp[i<span class="number">-1</span>]) dp[i + a[i]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i - a[i] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; dp[i - a[i] - <span class="number">1</span>]) dp[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (dp[n] ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    forn(tt, t) &#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Codeforces Round </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces Round </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程管理</title>
      <link href="/archives/3a046ccf.html"/>
      <url>/archives/3a046ccf.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux入门之进程管理"><a href="#Linux入门之进程管理" class="headerlink" title="Linux入门之进程管理"></a>Linux入门之进程管理</h1><h2 id="显示系统执行的进程"><a href="#显示系统执行的进程" class="headerlink" title="显示系统执行的进程"></a>显示系统执行的进程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -aux</span><br></pre></td></tr></table></figure><p>显示某一个进程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -aux | grep [commond名称]</span><br></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2022/10/11/6a8f39f5dcb569c1.png"></p><h2 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h2><p>查看进程树</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef | more //查看全部</span><br></pre></td></tr></table></figure><p>查看特定进程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef | grep [进程名]</span><br></pre></td></tr></table></figure><h2 id="终止进程kill和killall"><a href="#终止进程kill和killall" class="headerlink" title="终止进程kill和killall"></a>终止进程kill和killall</h2>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round</title>
      <link href="/archives/682df6fc.html"/>
      <url>/archives/682df6fc.html</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-Round-777-Div-2-A-D"><a href="#Codeforces-Round-777-Div-2-A-D" class="headerlink" title="Codeforces Round #777 (Div. 2) A-D"></a>Codeforces Round #777 (Div. 2) A-D</h1><p>比赛链接： </p><p>[<a href="https://codeforces.com/contest/1647]">https://codeforces.com/contest/1647]</a>: </p><h2 id="A-Madoka-and-Math-Dad"><a href="#A-Madoka-and-Math-Dad" class="headerlink" title="A. Madoka and Math Dad"></a>A. Madoka and Math Dad</h2><p><strong>构造</strong></p><p>题目大意：</p><blockquote><p>给定一个整数n，构造出找出一行中没有零且没有连续相等数字的最大数，使其数字之和为n。</p></blockquote><p>构造思路：</p><blockquote><p>如何使得构造的数最大：应该使它的数位尽可能大，所以应该尽可能拆成21，因为不能有连续的数。所以求出n&#x2F;3，就是21的个数，如果n%3 &#x3D;&#x3D; 1，说明多出了1，应该放在开头，如果n%3 &#x3D;&#x3D; 2，说明多出了2，应该放在结尾</p></blockquote><p>代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="type">int</span>  t = n / <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span>  d = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= t;i++) cout&lt;&lt;<span class="string">&quot;21&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Madoka-and-the-Elegant-Gift"><a href="#B-Madoka-and-the-Elegant-Gift" class="headerlink" title="B. Madoka and the Elegant Gift"></a>B. Madoka and the Elegant Gift</h2><p>题目大意：</p><blockquote><p>判断是否有两个相交的子矩形，有输出NO，没有则输出YES</p></blockquote><p>思路分析：</p><blockquote><p>算是一个结论，如果没有相交的子矩阵，那么相邻的四个格子不能有三个格子是矩阵的一部分，可以想象一下：如果四个相邻的格子有一个不是矩阵的，其他三个格子都是矩阵的一部分，那么就肯定是有相交的</p></blockquote><p>代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> s[<span class="number">1100</span>][<span class="number">1100</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;=  n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j++)&#123;</span><br><span class="line">cin&gt;&gt;s[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n - <span class="number">1</span>;i ++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m - <span class="number">1</span>;j++)&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(s[i][j] == <span class="string">&#x27;1&#x27;</span>)  cnt++;</span><br><span class="line"><span class="keyword">if</span>(s[i+<span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>) cnt++;</span><br><span class="line"><span class="keyword">if</span>(s[i+<span class="number">1</span>][j+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) cnt++;</span><br><span class="line"><span class="keyword">if</span>(s[i][j+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) cnt++;</span><br><span class="line"><span class="keyword">if</span>(cnt == <span class="number">3</span>) &#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Madoka-and-Childish-Pranks"><a href="#C-Madoka-and-Childish-Pranks" class="headerlink" title="C. Madoka and Childish Pranks"></a>C. Madoka and Childish Pranks</h2><p><strong>简单构造</strong></p><p>代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T); </span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; g[i] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i; i -- ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = m; j; j -- ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    res ++ ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i; i -- ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = m; j; j -- ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; i &gt; <span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, i - <span class="number">1</span>, j, i, j);</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; i == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, i, j - <span class="number">1</span>, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Madoka-and-the-Best-School-in-Russia"><a href="#D-Madoka-and-the-Best-School-in-Russia" class="headerlink" title="D. Madoka and the Best School in Russia"></a>D. Madoka and the Best School in Russia</h2><p><strong>构造</strong></p><p>题意：</p><blockquote><p>一个数是好数当且仅当其为d的倍数</p><p>一个数是美丽数当且仅当其为好数且不能被表示为两个好数的乘积</p><p>求是否有两种或以上的方式 ，将x分解为若干个美丽数的乘积</p></blockquote><p>思路分析：</p><blockquote><p>美丽数即可表示为 t x d 的形式，而将x分解为<br>$$<br>x &#x3D; y * d ^k<br>$$<br>显然k等于1的时候是不存在两种或以上的分解方法的</p><p>当k 等于2 的时候 如果y可以再分的话就可以分解为y<em>d^k 和 y1 * d * y2</em>d;那么y必须要为偶数才可以再分</p><p>当k &gt;&#x3D; 3 时，如果y为质数，d不为质数(我们可以拆开d，y不变)</p><p>只有当k &#x3D; 3并且d &#x3D; y^2的时候无解，因为如果d&#x3D;y^2，拆开的结果是y * d1 *  d 和 d2 * d; 如果d1 * y &#x3D;&#x3D; d 就不符合题意 而 d1 * y &#x3D;&#x3D; d1 * d2,d2 !&#x3D; y。所以d不能拆成y * y;</p></blockquote><p>代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="comment">// if(x &lt;= 1) return false;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= x / i;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(x % i ==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;d);</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line"><span class="keyword">if</span>(n % d == <span class="number">0</span>) n /= d,k++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> y = n;</span><br><span class="line"><span class="comment">//cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isprime</span>(y))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k &gt;= <span class="number">3</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">isprime</span>(y))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isprime</span>(d))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(d == <span class="number">1ll</span> * y * y &amp;&amp; k == <span class="number">3</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Codeforces Round </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell入门(一)</title>
      <link href="/archives/90e0ef92.html"/>
      <url>/archives/90e0ef92.html</url>
      
        <content type="html"><![CDATA[<h1 id="Shell概述"><a href="#Shell概述" class="headerlink" title="Shell概述"></a>Shell概述</h1><ol><li>Shell脚本入门</li><li>Shell变量</li><li>Shell内置命令</li><li>Shell运算符与执行运算命令</li><li>流程控制语句</li><li>Shell函数</li><li>Shell重定向</li><li>Shell好用的工具, cut sed awk sort</li><li>大厂常见企业面试题</li></ol><h1 id="Shell脚本入门：介绍"><a href="#Shell脚本入门：介绍" class="headerlink" title="Shell脚本入门：介绍"></a>Shell脚本入门：介绍</h1><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>理解Shell是什么</p><p>理解Shell脚本是什么</p><p>理解为什么学习Shell脚本(Shell脚本程序的作用)</p><p>linux系统默认的Shell解析器</p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>linux系统是如何操作计算机硬件CPU,内存,磁盘,显示器等?</p><p>答: 使用linux的内核操作计算机的硬件</p><h3 id="Shell介绍"><a href="#Shell介绍" class="headerlink" title="Shell介绍"></a>Shell介绍</h3><p>通过编写Shell命令发送给linux内核去执行, 操作就是计算机硬件. 所以Shell命令是用户操作计算机硬件的桥梁,</p><p>Shell是命令,  类似于windows系统Dos命令</p><p>Shell是一个门程序设计语言, Shell里面含有变量, 函数, 逻辑控制语句等等</p><h3 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>通过Shell命令或程序编程语言编写的Shell文本文件,  这就是Shell脚本 , 也叫Shell程序</p><h1 id="为什么学习Shell脚本"><a href="#为什么学习Shell脚本" class="headerlink" title="为什么学习Shell脚本?"></a>为什么学习Shell脚本?</h1><p>通过Shell命令与编程语言来提高linux系统的管理工作效率</p><h3 id="Shell的运行过程"><a href="#Shell的运行过程" class="headerlink" title="Shell的运行过程"></a>Shell的运行过程</h3><p>当用户下达指令给该操作系统的时候，实际上是把指令告诉shell，经过shell解释，处理后让内核做出相应的动作。 系统的回应和输出的信息也由shell处理，然后显示在用户的屏幕上。</p><h2 id="Shell解析器"><a href="#Shell解析器" class="headerlink" title="Shell解析器"></a>Shell解析器</h2><p>查看linux系统centos支持的shell解析器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure><p>介绍解析器类型</p><table><thead><tr><th>解析器类型</th><th>介绍</th></tr></thead><tbody><tr><td>&#x2F;bin&#x2F;sh</td><td>Bourne Shell,是UNIX最初使用的shell;</td></tr><tr><td><font color=red>&#x2F;bin&#x2F;bash</font></td><td><font color=red>Bourne Again Shell它是Bourne Shell的扩展，简称bash，是LinuxOS默认shell,有灵活和强大的编辑接口，同时又很友好的用户界面，交互性很强；</font></td></tr><tr><td>&#x2F;sbin&#x2F;nologin</td><td>未登录解析器,  shell设置为&#x2F;sbin&#x2F;nologin 是用于控制用户禁止登陆系统的, 有时候有些服务，比如邮件服务，大部分都是用来接收主机的邮件而已，并不需要登陆</td></tr><tr><td>&#x2F;bin&#x2F;dash</td><td>dash（Debian Almquist Shell），也是一种 Unix shell。它比 Bash 小，只需要较少的磁盘空间，但是它的对话性功能也较少，交互性较差。</td></tr><tr><td>&#x2F;bin&#x2F;csh</td><td>C Shell是C语言风格Shell</td></tr><tr><td>&#x2F;bin&#x2F;tcsh</td><td>是C Shell的一个扩展版本。</td></tr></tbody></table><h3 id="Centos默认的解析器是bash"><a href="#Centos默认的解析器是bash" class="headerlink" title="Centos默认的解析器是bash"></a>Centos默认的解析器是bash</h3><p>语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure><blockquote><p>含义:  打印输出当前系统环境使用的Shell解析器类型</p><p>echo  用于打印输出数据到终端</p><p><code>$SHELL</code>  是全局共享的读取解析器类型环境变量, 全局环境变量时所有的Shell程序都可以读取的变量,</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1、Shell是什么</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">是命令, 类似windows的dos命令</span><br><span class="line">又是一门程序设计语言, 里面含有变量, 函数, 逻辑控制语句等</span><br></pre></td></tr></table></figure><p>2、Shell脚本是什么</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">是一个文本文件, 里面可以编写Shell命令或进行编程, 形成一个可重用执行的脚本文件</span><br></pre></td></tr></table></figure><p>3、shell脚本的作用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">通过shell编程提高对linux系统管理工作效率</span><br></pre></td></tr></table></figure><p>4、linux系统默认的shell解析器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><h1 id="Shell脚本入门：编写格式与执行方式"><a href="#Shell脚本入门：编写格式与执行方式" class="headerlink" title="Shell脚本入门：编写格式与执行方式"></a>Shell脚本入门：编写格式与执行方式</h1><h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2><p>1、掌握shell脚本编写规范</p><p>2、掌握执行shell脚本文件的3种方式与区别</p><h2 id="Shell脚本文件编写规范"><a href="#Shell脚本文件编写规范" class="headerlink" title="Shell脚本文件编写规范"></a>Shell脚本文件编写规范</h2><h3 id="脚本文件后缀名规范"><a href="#脚本文件后缀名规范" class="headerlink" title="脚本文件后缀名规范"></a>脚本文件后缀名规范</h3><p>shell脚本文件就是一个文本文件,  后缀名建议使用 <code>.sh</code> 结尾</p><h3 id="首行格式规范"><a href="#首行格式规范" class="headerlink" title="首行格式规范"></a>首行格式规范</h3><p>首行需要设置Shell解析器的类型, 语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br></pre></td></tr></table></figure><blockquote><p>含义:  设置当前shell脚本文件采用bash解析器运行脚本代码</p></blockquote><h3 id="注释格式"><a href="#注释格式" class="headerlink" title="注释格式"></a>注释格式</h3><p>单行注释, 语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注释内容</span></span><br></pre></td></tr></table></figure><p>多行注释, 语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;!</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注释内容1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注释内容2</span></span><br><span class="line">!</span><br></pre></td></tr></table></figure><h2 id="shell脚本HelloWord入门案例"><a href="#shell脚本HelloWord入门案例" class="headerlink" title="shell脚本HelloWord入门案例"></a>shell脚本HelloWord入门案例</h2><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>创建一个Shell脚本文件helloworld.sh，输出hello world字符串</p><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>1、创建shell脚本文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch helloworld.sh</span><br></pre></td></tr></table></figure><p>2、编辑文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim helloworld.sh</span><br></pre></td></tr></table></figure><p>3、增加shell脚本文件内容如下，并保存退出</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>4、执行脚本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh helloworld.sh</span><br></pre></td></tr></table></figure><h2 id="脚本文件的常用执行3种方式"><a href="#脚本文件的常用执行3种方式" class="headerlink" title="脚本文件的常用执行3种方式"></a>脚本文件的常用执行3种方式</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ol><li><p>sh解析器执行方式</p><p>语法: <code>sh 脚本文件</code></p><p>介绍: 就是利用sh命令执行脚本文件,  本质就是使用Shell解析器运行脚本文件</p></li><li><p>bash解析器执行方式</p><p>语法: <code>bash 脚本文件</code></p><p>介绍: 就是利用bash命令执行脚本文件,  本质就是使用Shell解析器运行脚本文件</p></li><li><p>仅路径执行方式</p><p>语法: <code>./脚本文件</code></p><p>介绍:  执行当前目录下的脚本文件</p><p>注意:  脚本文件自己执行需要具有可执行权限, 否则无法执行</p></li></ol><h4 id="3种方式的区别"><a href="#3种方式的区别" class="headerlink" title="3种方式的区别"></a>3种方式的区别</h4><p>​sh或bash执行脚本文件方式是直接使用Shell解析器运行脚本文件, 不需要可执行权限</p><p>​     仅路径方式是执行脚本文件自己, 需要可执行权限</p><h4 id="执行脚本方式1-sh命令执行"><a href="#执行脚本方式1-sh命令执行" class="headerlink" title="执行脚本方式1-sh命令执行"></a>执行脚本方式1-sh命令执行</h4><p>相对路径效果</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh helloworld.sh</span><br></pre></td></tr></table></figure><p>绝对路径效果</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh /root/helloworld.sh</span><br></pre></td></tr></table></figure><h4 id="执行脚本方式3-仅路径执行"><a href="#执行脚本方式3-仅路径执行" class="headerlink" title="执行脚本方式3-仅路径执行"></a>执行脚本方式3-仅路径执行</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>步骤1：设置所有用户对此脚本文件增加可执行性权限</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod a+x 脚本文件</span><br></pre></td></tr></table></figure><p>步骤2：执行脚本语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">脚本文件的相对路径或绝对路径</span><br></pre></td></tr></table></figure><h5 id="示例：使用仅路径方式执行helloworld-sh脚本文件"><a href="#示例：使用仅路径方式执行helloworld-sh脚本文件" class="headerlink" title="示例：使用仅路径方式执行helloworld.sh脚本文件"></a>示例：使用仅路径方式执行helloworld.sh脚本文件</h5><p>添加执行权限</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod a+x helloworld.sh</span><br></pre></td></tr></table></figure><p>相对路径执行命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./helloworld.sh</span><br></pre></td></tr></table></figure><p>相对路径执行效果</p><p><img src="/assets/image-20200401215354868.png" alt="image-20200401215354868"></p><p>绝对路径执行命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/root/helloworld.sh</span><br></pre></td></tr></table></figure><p>绝对路径执行效果</p><p><img src="/assets/image-20200401215435317.png" alt="image-20200401215435317"></p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>1、shell脚本文件编写规范？</p><blockquote><p>​文件的后缀名: 建议使用 <code>.sh</code>  扩展名</p><p>​首行需要设置解析器类型  <code>#!/bin/bash</code></p><p>​脚本文件中的注释</p><p>​单行注释,  <code># 注释内容</code></p><p>​多行注释   <code>:&lt;&lt;!</code></p><p>​<code># 注释内容</code></p><p>​<code>!</code></p></blockquote><p>2、执行shell脚本文件有哪3种方式，并说明他们的区别？</p><blockquote><p>sh执行脚本文件</p><p>bash执行脚本文件</p><p>仅路径执行脚本文件</p><p>区别:  前2种是解析器直接执行不需要可执行权限, 最后一种是脚本文件自己执行需要可执行权限</p></blockquote><h1 id="Shell脚本入门：多命令处理"><a href="#Shell脚本入门：多命令处理" class="headerlink" title="Shell脚本入门：多命令处理"></a>Shell脚本入门：多命令处理</h1><h3 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h3><p>掌握shell脚本文件中执行多命令处理</p><h3 id="多命令处理介绍"><a href="#多命令处理介绍" class="headerlink" title="多命令处理介绍"></a>多命令处理介绍</h3><p>就是在Shell脚本文件中编写多个Shell命令</p><h3 id="案例需求"><a href="#案例需求" class="headerlink" title="案例需求"></a>案例需求</h3><p>已知目录&#x2F;root&#x2F;itheima目录，执行batch.sh脚本，实现在&#x2F;root&#x2F;itheima&#x2F;目录下创建一个one.txt,在one.txt文件中增加内容“Hello Shell”。</p><h3 id="步骤分析"><a href="#步骤分析" class="headerlink" title="步骤分析"></a>步骤分析</h3><ol><li><p>使用mkdir创建&#x2F;root&#x2F;itheima目录</p></li><li><p>创建脚本文件batch.sh</p></li><li><p>编辑脚本文件</p><p>3.1 命令1: touch创建文件, 文件名 <code>/root/itheima/one.txt</code></p><p>3.2 命令2: 输出数据”Hello Shell”到one.txt文件中</p><blockquote><p>输出数据到文件中的命令:</p><p><code>数据 &gt;&gt; 文件</code></p></blockquote></li><li><p>执行脚本文件</p></li></ol><h3 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>1、进入root目录，执行创建&#x2F;root&#x2F;itheima目录命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /root/itheima</span><br></pre></td></tr></table></figure><p>2、创建&#x2F;root&#x2F;batch.sh文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch batch.sh</span><br></pre></td></tr></table></figure><p>3、编辑batch.sh文件，编写shell命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim batch.sh</span><br></pre></td></tr></table></figure><p>3、编写命令</p><p>命令1：创建&#x2F;root&#x2F;itheima&#x2F;one.txt文件</p><p>命令2：输出“I love Shell”字符串数据到one.txt文件中</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">cd itheima     # 切换到itheima目录</span><br><span class="line">touch one.txt  # 创建文件one.txt</span><br><span class="line">echo &quot;Hello Shell&quot;&gt;&gt;/root/itheima/one.txt  #输出数据到one.txt文件中</span><br></pre></td></tr></table></figure><h3 id="运行脚本效果"><a href="#运行脚本效果" class="headerlink" title="运行脚本效果"></a>运行脚本效果</h3><p>运行batch.sh脚本文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh batch.sh</span><br></pre></td></tr></table></figure><p>查看one.txt文件内容</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat itheima/one.txt</span><br></pre></td></tr></table></figure><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>shell脚本文件中是否可以执行多命令处理？</p><p>可以</p><h1 id="Shell变量：环境变量"><a href="#Shell变量：环境变量" class="headerlink" title="Shell变量：环境变量"></a>Shell变量：环境变量</h1><h2 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h2><p>1、理解什么是系统环境变量？</p><p>2、掌握常用的系统环境变量都有哪些？</p><h2 id="Shell变量的介绍"><a href="#Shell变量的介绍" class="headerlink" title="Shell变量的介绍"></a>Shell变量的介绍</h2><p>变量用于存储管理临时的数据,    这些数据都是在运行内存中的.</p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><ol><li>系统环境变量</li><li>自定义变量</li><li>特殊符号变量</li></ol><h2 id="系统环境变量"><a href="#系统环境变量" class="headerlink" title="系统环境变量"></a>系统环境变量</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>是系统提供的共享变量.是linux系统加载Shell的配置文件中定义的变量共享给所有的Shell程序使用</p><h3 id="Shell的配置文件分类"><a href="#Shell的配置文件分类" class="headerlink" title="Shell的配置文件分类"></a>Shell的配置文件分类</h3><p>1.全局配置文件<br>&#x2F;etc&#x2F;profile<br>&#x2F;etc&#x2F;profile.d&#x2F;*.sh<br>&#x2F;etc&#x2F;bashrc</p><p>2.个人配置文件<br>当前用户&#x2F;.bash_profile<br>当前用户&#x2F;.bashrc</p><p>一般情况下，我们都是直接针对全局配置进行操作。</p><h3 id="环境变量分类"><a href="#环境变量分类" class="headerlink" title="环境变量分类"></a>环境变量分类</h3><p>在Linux系统中，环境变量按照其作用范围不同大致可以分为系统级环境变量和用户级环境变量。</p><p>系统级环境变量：Shell环境加载全局配置文件中的变量共享给所有用户所有Shell程序使用, 全局共享<br>用户级环境变量：Shell环境加载个人配置文件中的变量共享给当前用户的Shell程序使用, 登录用户使用</p><h3 id="查看当前Shell系统环境变量"><a href="#查看当前Shell系统环境变量" class="headerlink" title="查看当前Shell系统环境变量"></a>查看当前Shell系统环境变量</h3><p>查看命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">env</span><br></pre></td></tr></table></figure><h3 id="查看Shell变量-系统环境变量-自定义变量-函数"><a href="#查看Shell变量-系统环境变量-自定义变量-函数" class="headerlink" title="查看Shell变量(系统环境变量+自定义变量+函数)"></a>查看Shell变量(系统环境变量+自定义变量+函数)</h3><p>命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set</span><br></pre></td></tr></table></figure><h3 id="常用系统环境变量"><a href="#常用系统环境变量" class="headerlink" title="常用系统环境变量"></a>常用系统环境变量</h3><table><thead><tr><th>变量名称</th><th>含义</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;PATH&#x3D;&#x3D;</td><td>与windows环境变量PATH功能一样，设置命令的搜索路径，以冒号为分割</td></tr><tr><td>HOME</td><td>当前用户主目录：&#x2F;root</td></tr><tr><td>SHELL</td><td>当前shell解析器类型：&#x2F;bin&#x2F;bash</td></tr><tr><td>&#x3D;&#x3D;HISTFILE&#x3D;&#x3D;</td><td>显示当前用户执行命令的历史列表文件：&#x2F;root&#x2F;.bash_history</td></tr><tr><td>PWD</td><td>显示当前所在路径：&#x2F;root</td></tr><tr><td>OLDPWD</td><td>显示之前的路径</td></tr><tr><td>HOSTNAME</td><td>显示当前主机名：itheima</td></tr><tr><td>HOSTTYPE</td><td>显示主机的架构，是i386、i686、还是x86、x64等：x86_64</td></tr><tr><td>&#x3D;&#x3D;LANG&#x3D;&#x3D;</td><td>设置当前系统语言环境：zh_CN.UTF-8</td></tr></tbody></table><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>1.系统环境变量是什么?</p><blockquote><p>是系统提供的环境变量, 通过加载Shell配置文件中变量数据共享给Shell程序使用</p></blockquote><p>2.环境变量的分类?</p><blockquote><p>系统级环境变量,  Shell环境加载全局配置文件中定义的变量</p><p>用户级环境变量,  Shell环境加载个人配置文件中定义的变量</p></blockquote><p>3.env与set区别</p><blockquote><p>env用于查看系统环境变量</p><p>set用于查看系统环境变量+自定义变量+函数</p></blockquote><p>4.常用环境变量</p><table><thead><tr><th>变量名称</th><th>含义</th></tr></thead><tbody><tr><td>PATH</td><td>命令搜索的目录路径, 与windows的环境变量PATH功能一样</td></tr><tr><td>LANG</td><td>查询系统的字符集</td></tr><tr><td>HISTFILE</td><td>查询当前用户执行命令的历史列表</td></tr></tbody></table><h1 id="Shell变量：自定义变量"><a href="#Shell变量：自定义变量" class="headerlink" title="Shell变量：自定义变量"></a>Shell变量：自定义变量</h1><h2 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h2><p>理解自定义变量的分类</p><p>能够自定义变量进行增\删\改\查</p><h2 id="自定义变量介绍"><a href="#自定义变量介绍" class="headerlink" title="自定义变量介绍"></a>自定义变量介绍</h2><p>就是自己定义的变量</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>自定义局部变量</li><li>自定义常量</li><li>自定义全局变量</li></ol><h2 id="自定义局部变量"><a href="#自定义局部变量" class="headerlink" title="自定义局部变量"></a>自定义局部变量</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>就是定义在一个脚本文件中的变量, 只能在这个脚本文件中使用的变量, 就是局部变量</p><h3 id="定义与使用"><a href="#定义与使用" class="headerlink" title="定义与使用"></a>定义与使用</h3><p>定义语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var_name=value</span><br></pre></td></tr></table></figure><p>变量定义规则</p><ol><li>变量名称可以有字母,数字和下划线组成, 但是不能以数字开头</li><li>等号两侧不能有空格</li><li>在bash环境中, 变量的默认类型都是字符串类型, 无法直接进行数值运算</li><li>变量的值如果有空格, 必须使用双引号括起来</li><li>不能使用Shell的关键字作为变量名称</li></ol><p>查询变量值语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法1: 直接使用变量名查询</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">var_name</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法2: 使用花括号</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;var_name&#125;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">区别: 花括号方式适合拼接字符串</span></span><br></pre></td></tr></table></figure><p>注意: 如果<code>&quot;My name is $&#123;var2&#125;Style&quot;</code> 中 <code>$var2</code> 不带花括号, 系统会认为获取<code>$var2Style</code> 变量数据, 这个变量不存在就获取不到数据,执行效果如下</p><p>结论:  推荐大家使用花括号才是编程好习惯</p><h3 id="变量删除"><a href="#变量删除" class="headerlink" title="变量删除"></a>变量删除</h3><p>语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unset var_name</span><br></pre></td></tr></table></figure><h2 id="自定义常量"><a href="#自定义常量" class="headerlink" title="自定义常量"></a>自定义常量</h2><p>介绍</p><blockquote><p>就是变量设置值以后不可以修改的变量叫常量, 也叫只读变量</p></blockquote><p>语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readonly var_name</span><br></pre></td></tr></table></figure><h2 id="自定义全局变量"><a href="#自定义全局变量" class="headerlink" title="自定义全局变量"></a>自定义全局变量</h2><h3 id="父子Shell环境介绍"><a href="#父子Shell环境介绍" class="headerlink" title="父子Shell环境介绍"></a>父子Shell环境介绍</h3><p>例如:  有2个Shell脚本文件 A.sh 和 B.sh</p><p>如果 在A.sh脚本文件中执行了B.sh脚本文件, 那么A.sh就是父Shell环境, B.sh就是子Shell环境</p><h3 id="自定义全局变量介绍"><a href="#自定义全局变量介绍" class="headerlink" title="自定义全局变量介绍"></a>自定义全局变量介绍</h3><blockquote><p>就是在当前脚本文件中定义全局变量, 这个全局变量可以在当前Shell环境与子Shell环境中都可以使用</p></blockquote><h3 id="自定义全局变量语法"><a href="#自定义全局变量语法" class="headerlink" title="自定义全局变量语法"></a>自定义全局变量语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export var_name1 var_name2</span><br></pre></td></tr></table></figure><h3 id="案例需求-1"><a href="#案例需求-1" class="headerlink" title="案例需求"></a>案例需求</h3><p>测试全局变量在子Shell中是否可用,  在父Shell中是否可用</p><h3 id="案例实现步骤"><a href="#案例实现步骤" class="headerlink" title="案例实现步骤"></a>案例实现步骤</h3><ol><li><p>创建2个脚本文件 demo2.sh 和 demo3.sh</p></li><li><p>编辑demo2.sh </p><p>命令1:定义全局变量VAR4</p><p>命令2: 执行demo3.sh脚本文件</p></li><li><p>编辑demo3.sh</p><p>输出全局变量VAR4</p></li><li><p>执行demo2.sh脚本文件</p></li></ol><h3 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h3><ol><li><p>创建demo2.sh和demo3.sh文件</p></li><li><p>编辑demo2.sh, 里面定义变量VAR4并设置为全局, 并里面执行demo3.sh脚本文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim demo2.sh</span><br></pre></td></tr></table></figure></li><li><p>编辑demo3.sh,  里面打印VAR4</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim demo3.sh</span><br></pre></td></tr></table></figure></li><li><p>执行脚本文件demo2.sh,  观察打印VAR4效果 执行脚本文件后, 在交互式Shell环境打印VAR4,  观察打印VAR4效果</p></li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>全局变量在当前Shell环境与子Shell环境中可用, 父Shell环境中不可用</p><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>自定义变量的分类</p><blockquote><p>自定义局部变量:  就是在一个脚本文件内部使用 <code>var_name=value</code></p><p>自定义常量: 不可以修改值的变量, <code>readonly var_name</code></p><p>自定义全局变量:  设置变量在当前脚本文件中与子Shell环境可以使用的变量, <code>export var_name</code></p></blockquote><p>自定义变量进行增\删\改\查</p><blockquote><p>定义和修改: <code>var_name=value</code></p><p>查询:<code>$&#123;var_name&#125; 或 $var_name</code></p><p>删除: <code>unset var_name</code></p></blockquote><h1 id="Shell变量：特殊变量"><a href="#Shell变量：特殊变量" class="headerlink" title="Shell变量：特殊变量"></a>Shell变量：特殊变量</h1><h2 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h2><p>能够说出常用的特殊变量有哪些</p><h2 id="特殊变量：-n"><a href="#特殊变量：-n" class="headerlink" title="特殊变量：$n"></a>特殊变量：$n</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">n</span></span><br></pre></td></tr></table></figure><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">用于接收脚本文件执行时传入的参数</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">0 用于获取当前脚本文件名称的</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1~<span class="variable">$9</span>, 代表获取第一输入参数到第9个输入参数</span></span><br><span class="line">第10个以上的输入参数获取参数的格式: $&#123;数字&#125;, 否则无法获取</span><br></pre></td></tr></table></figure><h3 id="执行脚本文件传入参数语法"><a href="#执行脚本文件传入参数语法" class="headerlink" title="执行脚本文件传入参数语法"></a>执行脚本文件传入参数语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh 脚本文件 输入参数1 输入参数2 ...</span><br></pre></td></tr></table></figure><h3 id="案例需求-2"><a href="#案例需求-2" class="headerlink" title="案例需求"></a>案例需求</h3><p>创建脚本文件demo4.sh文件, 并在脚本文件内部执行打印脚本文件名字, 第一个输入参数, 第二个输入参数</p><h3 id="实现步骤-2"><a href="#实现步骤-2" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li><p>创建脚本文件demo4.sh</p></li><li><p>编辑demo4.sh的文件内容</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令1: 打印当前脚本文件名字</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令2: 打印第1个输入参数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令3: 打印第2个输入参数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令4: 打印第10个输入参数</span></span><br></pre></td></tr></table></figure></li><li><p>执行脚本文件demo4.sh</p></li></ol><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><ol><li><p>创建demo4.sh文件</p></li><li><p>编辑demo4.sh文件, 输出脚本文件名称\第一个输入参数\第二个输入参数</p></li><li><p>执行demo4.sh文件,输入输出参数itcast  itheima的2个输入参数, 观察效果</p></li></ol><h2 id="特殊变量："><a href="#特殊变量：" class="headerlink" title="特殊变量：$#"></a>特殊变量：$#</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="comment">#</span></span></span><br></pre></td></tr></table></figure><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p>获取所有输入参数的个数</p><h3 id="案例需求-3"><a href="#案例需求-3" class="headerlink" title="案例需求"></a>案例需求</h3><p>在demo4.sh中输出输入参数个数</p><h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h3><p>编辑demo4.sh, 输出输入参数个数</p><p>执行demo4.sh传入参数itcast, itheima,</p><h2 id="特殊变量：-、"><a href="#特殊变量：-、" class="headerlink" title="特殊变量：$*、$@"></a>特殊变量：<code>$*</code>、<code>$@</code></h2><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">*</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">@</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">含义都是获取所有输入参数, 用于以后输出所有参数</span></span><br></pre></td></tr></table></figure><p><code>$*</code>与<code>$@</code>区别</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.不使用双引号括起来, 功能一样</span><br><span class="line"><span class="meta prompt_">  $</span><span class="language-bash">*和<span class="variable">$@</span>获取所有输入参数,格式为: <span class="variable">$1</span> <span class="variable">$2</span> ... <span class="variable">$n</span></span></span><br><span class="line">2.使用双引号括起来</span><br><span class="line">  &quot;$*&quot;获取的所有参数拼接为一个字符串, 格式为: &quot;$1 $2 ... $n&quot;</span><br><span class="line">  &quot;$@&quot;获取一组参数列表对象, 格式为: &quot;$1&quot; &quot;$2&quot; ... &quot;$n&quot;</span><br><span class="line">  使用循环打印所有输入参数可以看出区别</span><br></pre></td></tr></table></figure><p>循环语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for var in 列表变量</span><br><span class="line">do# 循环开始</span><br><span class="line">   命令  # 循环体</span><br><span class="line">done    # 循环结束</span><br></pre></td></tr></table></figure><h3 id="案例需求-4"><a href="#案例需求-4" class="headerlink" title="案例需求"></a>案例需求</h3><p>在demo4.sh中循环打印输出所有输入参数, 体验<code>$*</code>与<code>$@</code>的区别</p><h3 id="实现步骤-3"><a href="#实现步骤-3" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>编辑demo4.sh脚本文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加命令: 实现直接输出所有输入后参数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加命令: 使用循环打印输出所有输入参数</span></span><br></pre></td></tr></table></figure><h3 id="演示-2"><a href="#演示-2" class="headerlink" title="演示"></a>演示</h3><ol><li><p>编辑demo4.sh文件</p><p><img src="/assets/image-20200610093208439.png" alt="image-20200610093208439"></p></li><li><p>直接输出所有输入参数, 与循环方式输出所有输入参数(使用双引号包含 <code>$*</code> 与 <code>$@</code>  )</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令1: 打印当前脚本文件名字</span></span><br><span class="line">echo &quot;当前脚本文件名称:$0&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令2: 打印第1个输入参数</span></span><br><span class="line">echo &quot;第一个输入参数:$1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令3: 打印第2个输入参数</span></span><br><span class="line">echo &quot;第二个输入参数:$2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令4: 打印第10个输入参数</span></span><br><span class="line">echo &quot;第十个输入参数不带花括号获取:$10&quot;</span><br><span class="line">echo &quot;第十个输入参数带花括号获取:$&#123;10&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令5 打印所有输入参数的个数</span></span><br><span class="line">echo &quot;所有输入参数个数:$&#123;#&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加命令: 实现直接输出所有输入后参数</span></span><br><span class="line">echo &#x27;使用$*直接输出:&#x27;$*</span><br><span class="line">echo &#x27;使用$@直接输出:&#x27;$@</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加命令: 使用循环打印输出所有输入参数</span></span><br><span class="line">echo &#x27;循环遍历输出$*所有参数&#x27;</span><br><span class="line">for item in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">   echo $item</span><br><span class="line">done</span><br><span class="line">echo &#x27;循环遍历输出$@所有参数&#x27;</span><br><span class="line">for item in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">   echo $item</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li><p>运行观察区别</p><p><img src="/assets/image-20200707090439984.png" alt="image-20200707090439984"></p></li></ol><h2 id="特殊变量：-？"><a href="#特殊变量：-？" class="headerlink" title="特殊变量：$？"></a>特殊变量：$？</h2><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">?</span></span><br></pre></td></tr></table></figure><h3 id="含义-2"><a href="#含义-2" class="headerlink" title="含义"></a>含义</h3><p>用于获取上一个Shell命令的退出状态码, 或者是函数的返回值</p><blockquote><p>每个Shell命令的执行都有一个返回值, 这个返回值用于说明命令执行是否成功</p><p>一般来说, 返回0代表命令执行成功, 非0代表执行失败</p></blockquote><h3 id="演示-3"><a href="#演示-3" class="headerlink" title="演示"></a>演示</h3><p>输入一个正确命令, 再输出<code>$?</code></p><p><img src="/assets/image-20200610114421826.png" alt="image-20200610114421826"></p><p>输入一个错误命令, 在输出<code>$?</code></p><p><img src="/assets/image-20200610114445468.png" alt="image-20200610114445468"></p><h2 id="特殊变量：-1"><a href="#特殊变量：-1" class="headerlink" title="特殊变量：$$"></a>特殊变量：$$</h2><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">$</span></span><br></pre></td></tr></table></figure><h3 id="含义-3"><a href="#含义-3" class="headerlink" title="含义"></a>含义</h3><p>用于获取当前Shell环境的进程ID号</p><h3 id="演示-4"><a href="#演示-4" class="headerlink" title="演示"></a>演示</h3><p>查看当前Shell环境进程编号</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -aux|grep bash</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200610114834462.png" alt="image-20200610114834462"></p><p>输出 $$  显示当前shell环境进程编号</p><p><img src="/assets/image-20200610114956474.png" alt="image-20200610114956474"></p><h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><p>常用的特殊符号变量如下</p><table><thead><tr><th>特殊变量</th><th>含义</th></tr></thead><tbody><tr><td><code>$n</code></td><td>获取输入参数的<br><code>$0</code>,  获取当前Shell脚本文件名字<br><code>$1~$9</code>, 获取第一个输入参数到第九个输入参数<br><code>$&#123;10&#125;</code>  获取10和10以上的参数需要使用花括号</td></tr><tr><td><code>$#</code></td><td>获取所有输入参数的个数</td></tr><tr><td><code>$*</code> 与 <code>$@</code></td><td>获取所有输入参数数据<br>区别: 如果不使用双引号, 功能一样, <br>获取所有参数数据为一个字符串, 如果使用了双引号, <br><code>$@</code>获取的就是参数列表对象, 每个参数都是一个独立字符串,</td></tr><tr><td><code>$?</code></td><td>获取上一个命令的退出状态码, 一般;来说0代表命令成功, 非0代表执行失败</td></tr><tr><td><code>$$</code></td><td>获取当前shell环境进程的ID号</td></tr></tbody></table><h1 id="Shell环境变量深入：自定义系统环境变量"><a href="#Shell环境变量深入：自定义系统环境变量" class="headerlink" title="Shell环境变量深入：自定义系统环境变量"></a>Shell环境变量深入：自定义系统环境变量</h1><h2 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h2><p>能够自定义系统级环境变量</p><h2 id="全局配置文件-x2F-etc-x2F-profile应用场景"><a href="#全局配置文件-x2F-etc-x2F-profile应用场景" class="headerlink" title="全局配置文件&#x2F;etc&#x2F;profile应用场景"></a>全局配置文件&#x2F;etc&#x2F;profile应用场景</h2><p>当前用户进入Shell环境初始化的时候会加载全局配置文件&#x2F;etc&#x2F;profile里面的环境变量, 供给所有Shell程序使用</p><p>以后只要是所有Shell程序或命令使用的变量, 就可以定义在这个文件中</p><h2 id="案例演示-1"><a href="#案例演示-1" class="headerlink" title="案例演示"></a>案例演示</h2><h3 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h3><p>&#x2F;etc&#x2F;profile定义存储自定义系统级环境变量数据</p><h3 id="创建环境变量步骤"><a href="#创建环境变量步骤" class="headerlink" title="创建环境变量步骤"></a>创建环境变量步骤</h3><ol><li><p>编辑&#x2F;etc&#x2F;profile全局配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加命令: 定义变量VAR1=VAR1 并导出为环境变量</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">扩展: vim里面的命令模式使用G快速定位到文件末尾位置, 使用gg定位到文件首行位置</span></span><br></pre></td></tr></table></figure></li><li><p>重载配置文件&#x2F;etc&#x2F;profile, 因为配置文件修改后要立刻加载里面的数据就需要重载, 语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>在Shell环境中读取系统级环境变量VAR1</p></li></ol><h3 id="创建环境变量演示"><a href="#创建环境变量演示" class="headerlink" title="创建环境变量演示"></a>创建环境变量演示</h3><p>编辑&#x2F;etc&#x2F;profile文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>添加设置变量VAR1&#x3D;VAR1并导出成为环境变量, 在&#x2F;etc&#x2F;profile文件末尾添加如下命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建环境变量</span></span><br><span class="line">VAR1=VAR1</span><br><span class="line">export VAR1</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200409124318865.png" alt="image-20200409124318865"></p><p>3、保存&#x2F;etc&#x2F;profile退出</p><p>4、重新加载&#x2F;etc&#x2F;profile文件数据更新系统环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果这一步不执行，无法读取更新的环境变量</p></blockquote><p>3、输出环境变量VAR1</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $VAR1</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200409124934898.png" alt="image-20200409124934898"></p><h2 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h2><p>如何自定义系统级环境变量</p><blockquote><ol><li>系统级全局配置文件: &#x2F;etc&#x2F;profile</li><li>设置环境变量: <code>export var_name=value</code>,  注意环境变量建议变量名全部大写</li><li>修改了&#x2F;etc&#x2F;profile文件后, 要立刻加载修改的数据需要重载配置文件: <code>source /etc/profile</code></li></ol></blockquote><h1 id="Shell环境变量深入：加载流程原理介绍"><a href="#Shell环境变量深入：加载流程原理介绍" class="headerlink" title="Shell环境变量深入：加载流程原理介绍"></a>Shell环境变量深入：加载流程原理介绍</h1><h2 id="目标-7"><a href="#目标-7" class="headerlink" title="目标"></a>目标</h2><ol><li>能够说出交互式Shell与非交互式Shell</li><li>能够说出登录Shell与非登录Shell环境</li></ol><h2 id="Shell工作环境介绍"><a href="#Shell工作环境介绍" class="headerlink" title="Shell工作环境介绍"></a>Shell工作环境介绍</h2><p>用户进入linux系统就会初始化Shell环境, 这个环境会加载全局配置文件和用户个人配置文件中环境变量.每个脚本文件都有自己的Shell环境</p><h2 id="shell工作环境分类"><a href="#shell工作环境分类" class="headerlink" title="shell工作环境分类"></a>shell工作环境分类</h2><h3 id="交互式与非交互式shell"><a href="#交互式与非交互式shell" class="headerlink" title="交互式与非交互式shell"></a>交互式与非交互式shell</h3><p>交互式Shell</p><blockquote><p>与用户进行交互, 互动. 效果就是用户输入一个命令, Shell环境立刻反馈响应.</p></blockquote><p>非交互式Shell</p><blockquote><p>不需要用户参与就可以执行多个命令. 比如一个脚本文件含有多个命令,直接执行并给出结果</p></blockquote><h3 id="登录Shell与非登录Shell环境"><a href="#登录Shell与非登录Shell环境" class="headerlink" title="登录Shell与非登录Shell环境"></a>登录Shell与非登录Shell环境</h3><table><thead><tr><th>类型名称</th><th>含义</th></tr></thead><tbody><tr><td>shell登录环境</td><td>需要用户名\密码登录的Shell环境</td></tr><tr><td>shell非登录环境</td><td>不需要用户名,密码进入的Shell环境 或 执行脚本文件</td></tr></tbody></table><blockquote><p>注意：不同的工作环境加载环境变量流程不一样</p></blockquote><h2 id="环境变量初始化流程"><a href="#环境变量初始化流程" class="headerlink" title="环境变量初始化流程"></a>环境变量初始化流程</h2><p>1.全局配置文件<br>&#x2F;etc&#x2F;profile<br>&#x2F;etc&#x2F;profile.d&#x2F;*.sh<br>&#x2F;etc&#x2F;bashrc</p><p>2.个人配置文件<br>当前用户&#x2F;.bash_profile<br>当前用户&#x2F;.bashrc</p><p>环境变量加载初始化过程</p><p><img src="/assets/image-20200707120357693.png" alt="image-20200707120357693"></p><h2 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h2><ol><li><p>能够说出交互式Shell与非交互式Shell</p><blockquote><p>交互式Shell:  就是需要用户参与互动的Shell环境, 效果用户输入一个命令, 环境就立刻响应结果</p><p>非交互式Shell:  只执行命令, 不需要用户的参与</p></blockquote></li><li><p>能够说出登录Shell与非登录Shell环境</p><blockquote><p>登录Shell环境:  要以用户名与密码登录到系统默认采用登录Shell环境</p><p>非登录Shell环境: 不实用用户名与密码进入linux系统的Shell环境</p></blockquote></li></ol><h1 id="Shell环境变量深入：加载流程测试"><a href="#Shell环境变量深入：加载流程测试" class="headerlink" title="Shell环境变量深入：加载流程测试"></a>Shell环境变量深入：加载流程测试</h1><h2 id="目标-8"><a href="#目标-8" class="headerlink" title="目标"></a>目标</h2><p>理解Shell环境变量的加载流程测试</p><p>能够知道环境变量应该配置在哪里</p><h2 id="切换Shell环境执行脚本文件介绍"><a href="#切换Shell环境执行脚本文件介绍" class="headerlink" title="切换Shell环境执行脚本文件介绍"></a>切换Shell环境执行脚本文件介绍</h2><p>在执行一个脚本文件时可以指定具体Shell环境进行执行脚本文件, 这个就是切换Shell环境执行脚本</p><h2 id="Shell登录环境执行脚本文件语法"><a href="#Shell登录环境执行脚本文件语法" class="headerlink" title="Shell登录环境执行脚本文件语法"></a>Shell登录环境执行脚本文件语法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh/bash -l/--login 脚本文件</span><br></pre></td></tr></table></figure><blockquote><p>含义: 先加载Shell登录环境流程初始化环境变量, 再执行脚本文件</p></blockquote><h2 id="Shell非登录环境变量执行脚本文件语法"><a href="#Shell非登录环境变量执行脚本文件语法" class="headerlink" title="Shell非登录环境变量执行脚本文件语法"></a>Shell非登录环境变量执行脚本文件语法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash # 加载Shell非登录环境</span><br><span class="line">sh/bash 脚本文件 # 直接执行脚本文件</span><br></pre></td></tr></table></figure><blockquote><p>含义: 先执行加载Shell非登录环境流程初始化环境变量, 再执行脚本文件</p></blockquote><h2 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h2><h3 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h3><p>Shell登录环境会运行&#x2F;etc&#x2F;profile</p><p>Shell非登录环境会运行&#x2F;.bashrc</p><p>在&#x2F;etc&#x2F;profile与&#x2F;当前用户&#x2F;.bashrc文件分别设置环境变量数据，然后在shell脚本文件中输出环境变量数据，最后切换不同环境执行shell脚本文件观察验证上面的流程运行</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li><p>清理工作, 清理&#x2F;etc&#x2F;profile文件中VAR1环境变量进行删除, 并且重载这个配置文件</p></li><li><p>编辑&#x2F;etc&#x2F;profile, 增加环境变量VAR1&#x3D;VAR1</p></li><li><p>编辑&#x2F;root&#x2F;.bashrc, 增加环境变量VAR2&#x3D;VAR2</p></li><li><p>创建demo1.sh文件, 读取环境变量数据进行打印</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出环境变量VAR1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出环境变量VAR2</span></span><br></pre></td></tr></table></figure></li><li><p>以Shell非登录环境执行demo1.sh脚本文件, 观察只会输出VAR2, 不会输出VAR1</p></li><li><p>以Shell登录环境执行demo1.sh脚本文件, 观察会输出VAR2和VAR1</p></li></ol><h3 id="演示-5"><a href="#演示-5" class="headerlink" title="演示"></a>演示</h3><p>编辑&#x2F;etc&#x2F;profile文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>编辑添加如下内容，保存退出</p><p><img src="/assets/image-20200608180928458.png" alt="image-20200608180928458"></p><p>在root目录下,编辑.bashrc文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim .bashrc</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200608180131769.png" alt="image-20200608180131769"></p><p>编辑添加如下最后2行内容，保存退出</p><p><img src="/assets/image-20200608181029028.png" alt="image-20200608181029028"></p><p>创建文件demo1.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch demo1.sh</span><br></pre></td></tr></table></figure><p>编辑文件demo1.sh，添加如下内容</p><p><img src="/assets/image-20200608180411557.png" alt="image-20200608180411557"></p><p>直接执行脚本文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash demo1.sh</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200608180453317.png" alt="image-20200608180453317"></p><blockquote><p>直接执行脚本文件, 即没有加载登录Shell环境变量, 也没有加载非登录Shell环境变量</p></blockquote><p>先加载非登录Shell环境变量, 然后执行脚本文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line">bash demo1.sh</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200608181127345.png" alt="image-20200608181127345"></p><blockquote><p>Shell非登录环境会加载文件 <code>当前用户/.bashrc</code>  的环境变量数据</p><p>所以这里会输出VAR2的环境变量数据</p></blockquote><p>先加载登录Shell环境变量, 然后执行脚本文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -l demo1.sh</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200608181329353.png" alt="image-20200608181329353"></p><blockquote><p>Shell登录环境会加载文件 <code>etc/profile</code>和<code>当前用户/.bashrc</code>  的环境变量数据</p><p>所以这里会输出VAR1和VAR2的环境变量数据</p></blockquote><h2 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h2><p>1、Shell环境变量初始化加载原理过程</p><table><thead><tr><th>分类</th><th>初始化环境变量过程执行文件顺序</th></tr></thead><tbody><tr><td>shell登录环境初始化过程</td><td>&#x2F;etc&#x2F;profile–》&#x2F;etc&#x2F;profile.d&#x2F;*.sh–》<del>&#x2F;.bash_profile–》</del>&#x2F;.bashrc–》&#x2F;etc&#x2F;bashrc</td></tr><tr><td>shell非登录环境初始化过程</td><td>~&#x2F;.bashrc–》&#x2F;etc&#x2F;bashrc–》&#x2F;etc&#x2F;profile.d&#x2F;*.sh</td></tr></tbody></table><p>2、那么以到底将环境变量定义到哪里呢？&#x2F;etc&#x2F;profile与&#x2F;etc&#x2F;bashrc的区别？</p><p>需要登录的执行的shell脚本读取的环境变量配置在：&#x2F;etc&#x2F;profile、&#x2F;当前用户&#x2F;.bash_profile</p><p>不需要登录的用户执行的shell脚本读取的环境变量配置在：&#x2F;当前用户&#x2F;.bashrc、&#x2F;etc&#x2F;bashrc</p><h1 id="Shell环境变量深入：识别Shell环境类型"><a href="#Shell环境变量深入：识别Shell环境类型" class="headerlink" title="Shell环境变量深入：识别Shell环境类型"></a>Shell环境变量深入：识别Shell环境类型</h1><h2 id="目标-9"><a href="#目标-9" class="headerlink" title="目标"></a>目标</h2><p>理解如何识别shell登录环境与非登录环境</p><h2 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h2><p>使用$0识别环境语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $0</span><br></pre></td></tr></table></figure><blockquote><p>输出 <code>-bash</code> 代表：shell登录环境</p><p>输出 <code>bash</code> 代表：  shell非登录环境</p><p>注意：这个 <code>$0</code> 环境变量如果用在子shell中(shell脚本文件)输出Shell脚本本身的文件名 </p></blockquote><p>bash命令语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash</span><br></pre></td></tr></table></figure><blockquote><p>bash命令：用于切换为Shell非登录环境</p></blockquote><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>1、直接登录系统为shell登录环境输出 $0 观察输出信息效果</p><p>2、使用 bash 命令切换为shell非登录环境输出 $0 观察输出信息效果</p><p>3、创建test.sh脚本文件，编辑添加输出 $0 ,编程保存完成后执行test.sh脚本文件观察输出信息效果</p><h3 id="演示-6"><a href="#演示-6" class="headerlink" title="演示"></a>演示</h3><p>直接登录linux系统使用如下命令效果</p><p><img src="/assets/image-20200408201336071.png" alt="image-20200408201336071"></p><blockquote><p>bash命令将当前环境转换为Shell非登录环境</p></blockquote><h2 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h2><p>1、如何识别shell登录环境与非登录环境？</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">0 用于获取当前Shell环境的类型,  bash代表Shell非登录环境, -bash 代表Shell登录环境</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$0</span>不可以在脚本文件中使用, 因为代表获取脚本文件名字</span></span><br></pre></td></tr></table></figure><h1 id="Shell环境变量深入：详细切换Shell环境"><a href="#Shell环境变量深入：详细切换Shell环境" class="headerlink" title="Shell环境变量深入：详细切换Shell环境"></a>Shell环境变量深入：详细切换Shell环境</h1><h2 id="目标-10"><a href="#目标-10" class="headerlink" title="目标"></a>目标</h2><p>理解切换shell环境的命令</p><h2 id="切换shell环境命令介绍"><a href="#切换shell环境命令介绍" class="headerlink" title="切换shell环境命令介绍"></a>切换shell环境命令介绍</h2><ol><li><p>直接登录加载shell登录环境</p></li><li><p>su切换用户加载Shell登录与Shell非登录环境</p></li><li><p>bash加载Shell登录与Shell非登录环境</p></li></ol><h2 id="切换Shell环境命令演示"><a href="#切换Shell环境命令演示" class="headerlink" title="切换Shell环境命令演示"></a>切换Shell环境命令演示</h2><h3 id="切换环境方式1：直接登录系统"><a href="#切换环境方式1：直接登录系统" class="headerlink" title="切换环境方式1：直接登录系统"></a>切换环境方式1：直接登录系统</h3><h5 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h5><p>直接在虚拟机上使用用户名与密码登录linux系统或使用客户端直接连接远程linux系统</p><h5 id="演示-7"><a href="#演示-7" class="headerlink" title="演示"></a>演示</h5><p>虚拟机本地直接登录演示</p><p><img src="/assets/image-20200408235243772.png" alt="image-20200408235243772"></p><p>客户端远程采用SSH登录演示</p><p><img src="/assets/image-20200408235629776.png" alt="image-20200408235629776"></p><h3 id="切换环境方式2：su切换用户登录"><a href="#切换环境方式2：su切换用户登录" class="headerlink" title="切换环境方式2：su切换用户登录"></a>切换环境方式2：su切换用户登录</h3><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><p>语法1</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su 用户名 --login </span><br><span class="line">或</span><br><span class="line">su 用户名 -l</span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">切换到指定用户, 加载Shell登录环境变量</span></span><br></pre></td></tr></table></figure><p>语法2</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su 用户名  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到指定用户,  加Shell非登录环境变量</span></span><br></pre></td></tr></table></figure><h5 id="分析步骤"><a href="#分析步骤" class="headerlink" title="分析步骤"></a>分析步骤</h5><p>1、创建普通用户userA</p><p>2、切换到用户userA，使用-l加载Shell登录环境变量  ,  输出环境变量$0，观察输出-bash</p><p>4、使用exit退出userA</p><p>5、切换到用户userA，加载Shell非登录环境变量，输出环境变量$0，观察输出bash</p><h5 id="演示-8"><a href="#演示-8" class="headerlink" title="演示"></a>演示</h5><p>创建普通用户userA</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd -m userA</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200409162546096.png" alt="image-20200409162546096"></p><p>以Shell登录环境执行切换到用户userA，输出环境变量$0，输出 -bash 说明当前为Shell登录环境</p><p><img src="/assets/image-20200409162630366.png" alt="image-20200409162630366"></p><p>使用exit退出userA</p><p><img src="/assets/image-20200409162938320.png" alt="image-20200409162938320"></p><p>以Shell非登录环境执行切换到用户userA，输出环境变量$0，输出 bash  说明当前为Shell非登录环境</p><p><img src="/assets/image-20200409162957086.png" alt="image-20200409162957086"></p><h3 id="切换环境方式3：bash切换"><a href="#切换环境方式3：bash切换" class="headerlink" title="切换环境方式3：bash切换"></a>切换环境方式3：bash切换</h3><h5 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h5><p>语法1:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash  # 加载【Shell非登录环境】</span><br></pre></td></tr></table></figure><p>语法2：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -l  Shell脚本文件 /  bash --login shell脚本文件</span><br><span class="line">sh -l shell脚本文件 / sh --login shell脚本文件</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先加载【Shell登录环境】然后运行指定Shell脚本文件</span></span><br></pre></td></tr></table></figure><h5 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h5><p>使用bash执行test.sh脚本文件，发生错误说明当前环境为Shell非登录环境</p><h5 id="演示-9"><a href="#演示-9" class="headerlink" title="演示"></a>演示</h5><p><img src="/assets/image-20200409165207091.png" alt="image-20200409165207091"></p><h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell入门(二)</title>
      <link href="/archives/3fd174f0.html"/>
      <url>/archives/3fd174f0.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>能够使用字符串的3种方式</p><p>掌握Shell字符串拼接</p><p>掌握shell字符串截取的常用格式</p><p>能够定义Shell索引数组和关联数组</p><p>能够使用内置命令alias,echo,read,exit,declare操作</p><p>掌握Shell的运算符操作</p><h1 id="Shell字符串变量"><a href="#Shell字符串变量" class="headerlink" title="Shell字符串变量"></a>Shell字符串变量</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>字符串（String）就是一系列字符的组合。字符串是 Shell 编程中最常用的数据类型之一（除了数字和字符串，也没有其他类型了）</p><h2 id="字符串的3种格式"><a href="#字符串的3种格式" class="headerlink" title="字符串的3种格式"></a>字符串的3种格式</h2><ol><li><p>单引号方式</p></li><li><p>双引号方式, 推荐</p></li><li><p>不用引号方式</p></li></ol><h2 id="字符串的3种格式区别"><a href="#字符串的3种格式区别" class="headerlink" title="字符串的3种格式区别"></a>字符串的3种格式区别</h2><ol><li><p>使用单引号 <code>&#39;&#39;</code>  的字符串：</p><p>任何字符都会原样输出，在其中使用变量是无效的。</p></li><li><p>由双引号<code>&quot; &quot;</code>包围的字符串：</p><p>其中包含了变量，那么该变量会被解析得到值，而不是原样输出。</p><p>字符串中还可以出现双引号的子字符串，但是需要转义。</p><p>3.不被引号包围的字符串</p><p>不被引号包围的字符串中出现变量时也会被解析，这一点和双引号<code>&quot; &quot;</code>包围的字符串一样。</p><p>字符串中不能出现空格，否则空格后边的字符串会作为其他变量或者命令解析。</p></li></ol><h2 id="获取字符串的长度"><a href="#获取字符串的长度" class="headerlink" title="获取字符串的长度"></a>获取字符串的长度</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;<span class="comment">#字符串变量名&#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>获取字符串的字符长度</p><h2 id="字符串拼接方式"><a href="#字符串拼接方式" class="headerlink" title="字符串拼接方式"></a>字符串拼接方式</h2><ol><li><p>无符号拼接</p></li><li><p>双引号拼接</p></li><li><p>混合拼接</p><h2 id="字符串截取语法"><a href="#字符串截取语法" class="headerlink" title="字符串截取语法"></a>字符串截取语法</h2></li></ol><table><thead><tr><th>格式</th><th>说明</th></tr></thead><tbody><tr><td><code>$&#123;变量名:start:length&#125;</code></td><td>从 string 字符串的左边第 start 个字符开始，<br>向右截取 length 个字符。</td></tr><tr><td><code>$&#123;变量名:start&#125;</code></td><td>从 string 字符串的左边第 start 个字符开始截取，直到最后。</td></tr><tr><td><code>$&#123;变量名:0-start:length&#125;</code></td><td>从 string 字符串的右边第 start 个字符开始，<br>向右截取 length 个字符。</td></tr><tr><td><code>$&#123;变量名:0-start&#125;</code></td><td>从 string 字符串的右边第 start 个字符开始截取，直到最后。</td></tr><tr><td><code>$&#123;变量名#*chars&#125;</code></td><td>从 string 字符串第一次出现 *chars 的位置开始，<br>截取 *chars 右边的所有字符。</td></tr><tr><td><code>$&#123;变量名##*chars&#125;</code></td><td>从 string 字符串最后一次出现 *chars 的位置开始，<br>截取 *chars 右边的所有字符。</td></tr><tr><td><code>$&#123;变量名%chars*&#125;</code></td><td>从 string 字符串最后第一次出现 chars* 的位置开始，<br>截取 chars* 左边的所有字符。</td></tr><tr><td><code>$&#123;变量名%%chars*&#125;</code></td><td>从 string 字符串第一次出现 chars* 的位置开始，<br>截取 chars* 左边的所有字符</td></tr></tbody></table><h2 id="截取演示"><a href="#截取演示" class="headerlink" title="截取演示"></a>截取演示</h2><h1 id="Shell索引数组变量：定义-获取-拼接-删除"><a href="#Shell索引数组变量：定义-获取-拼接-删除" class="headerlink" title="Shell索引数组变量：定义-获取-拼接-删除"></a>Shell索引数组变量：定义-获取-拼接-删除</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>Shell 支持数组（Array）,   数组是若干数据的集合，其中的每一份数据都称为数组的元素。</p><blockquote><p>注意Bash Shell 只支持一维数组，不支持多维数组。</p></blockquote><h2 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>在 Shell 中，用括号<code>( )</code>来表示数组，数组元素之间用空格来分隔. 语法为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array_name=(item1  item2 ...)  # 方式1</span><br><span class="line">array_name=([索引下标1]=item1  [索引下标2]=item2  ...)  # 方式2</span><br></pre></td></tr></table></figure><blockquote><p>注意，赋值号 <code>=</code> 两边不能有空格</p></blockquote><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>1.定义数字存储100,3,22,58,77,17,20</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nums=(29 100 13 8 91 44)</span><br></pre></td></tr></table></figure><p>2.Shell 是弱类型的，它并不要求所有数组元素的类型必须相同</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arr=(20 56 &quot;http://www.itcast.cn/&quot;)</span><br></pre></td></tr></table></figure><p>Shell数组元素定义后不是固定的,  定义后还可以赋值</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arr[6]=100</span><br></pre></td></tr></table></figure><p>3.可以给指定元素赋值初始化</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arr2=([0]=1 [2]=100 [4]=aa)</span><br></pre></td></tr></table></figure><blockquote><p>由于上面只赋值了3个元素, 所以数组的长度是3</p></blockquote><p><img src="/assets/image-20200629143058345.png" alt="image-20200629143058345"></p><h2 id="数组的获取"><a href="#数组的获取" class="headerlink" title="数组的获取"></a>数组的获取</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>1.通过下标获取元素值,index从0开始</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;arr[index]&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意使用<code>&#123; &#125;</code></p></blockquote><p>2.获取值同时复制给其他变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">item=$&#123;arr[index]&#125;</span><br></pre></td></tr></table></figure><p>3.使用 <code>@</code> 或 <code>*</code> 可以获取数组中的所有元素</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;arr[@]&#125;</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;arr[*]&#125;</span></span><br></pre></td></tr></table></figure><p>4.获取数组的长度或个数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;<span class="comment">#arr[@]&#125;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;<span class="comment">#arr[*]&#125;</span></span></span><br></pre></td></tr></table></figure><p>5.获取数组指定元素的字符程度</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;<span class="comment">#arr[索引]&#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h3><p><img src="/assets/image-20200629143255421.png" alt="image-20200629143255421"></p><p><img src="/assets/image-20200629144217560.png" alt="image-20200629144217560"></p><p><img src="/assets/image-20200629144245753.png" alt="image-20200629144245753"></p><p><img src="/assets/image-20200629144359259.png" alt="image-20200629144359259"></p><h2 id="数组的拼接"><a href="#数组的拼接" class="headerlink" title="数组的拼接"></a>数组的拼接</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>所谓 Shell 数组拼接（数组合并），就是将两个数组连接成一个数组</p><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><p>使用 <code>@</code> 和 <code>*</code> 获取数组所有元素之后进行拼接</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array_new=($&#123;array1[@]&#125; $&#123;array2[@]&#125; ...)</span><br><span class="line">array_new=($&#123;array1[*]&#125; $&#123;array2[*]&#125; ...)</span><br></pre></td></tr></table></figure><h3 id="演示-2"><a href="#演示-2" class="headerlink" title="演示"></a>演示</h3><p><img src="/assets/image-20200629145734269.png" alt="image-20200629145734269"></p><h2 id="数组的删除"><a href="#数组的删除" class="headerlink" title="数组的删除"></a>数组的删除</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>删除数组指定元素数据和删除整个数组数据</p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><p>删除数组指定元素数据</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unset array_name[index]</span><br></pre></td></tr></table></figure><p>删除整个数组</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unset array_name</span><br></pre></td></tr></table></figure><h3 id="演示-3"><a href="#演示-3" class="headerlink" title="演示"></a>演示</h3><p><img src="/assets/image-20200629163807706.png" alt="image-20200629163807706"></p><h1 id="Shell内置命令"><a href="#Shell内置命令" class="headerlink" title="Shell内置命令"></a>Shell内置命令</h1><h2 id="内置命令介绍"><a href="#内置命令介绍" class="headerlink" title="内置命令介绍"></a>内置命令介绍</h2><p>Shell 内置命令，就是由 Bash Shell 自身提供的命令，而不是文件系统中的可执行文件。</p><p>使用type 来确定一个命令是否是内置命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">type 命令</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200630083936549.png" alt="image-20200630083936549"></p><p>通常来说，内置命令会比外部命令执行得更快，执行外部命令时不但会触发磁盘 I&#x2F;O，还需要 fork 出一个单独的进程来执行，执行完成后再退出。而执行内置命令相当于调用当前 Shell 进程的一个函数, 还是一个进程, 减少了上下文切换。</p><h2 id="内置命令列表"><a href="#内置命令列表" class="headerlink" title="内置命令列表"></a>内置命令列表</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>:</td><td>扩展参数列表，执行重定向操作</td></tr><tr><td>.</td><td>读取并执行指定文件中的命令（在当前 shell 环境中）</td></tr><tr><td>&#x3D;&#x3D;alias&#x3D;&#x3D;</td><td>为指定命令定义一个别名</td></tr><tr><td>bg</td><td>将作业以后台模式运行</td></tr><tr><td>bind</td><td>将键盘序列绑定到一个 readline 函数或宏</td></tr><tr><td>break</td><td>退出 for、while、select 或 until 循环</td></tr><tr><td>builtin</td><td>执行指定的 shell 内建命令</td></tr><tr><td>caller</td><td>返回活动子函数调用的上下文</td></tr><tr><td>cd</td><td>将当前目录切换为指定的目录</td></tr><tr><td>command</td><td>执行指定的命令，无需进行通常的 shell 查找</td></tr><tr><td>compgen</td><td>为指定单词生成可能的补全匹配</td></tr><tr><td>complete</td><td>显示指定的单词是如何补全的</td></tr><tr><td>compopt</td><td>修改指定单词的补全选项</td></tr><tr><td>continue</td><td>继续执行 for、while、select 或 until 循环的下一次迭代</td></tr><tr><td>&#x3D;&#x3D;declare&#x3D;&#x3D;</td><td>声明一个变量或变量类型。</td></tr><tr><td>dirs</td><td>显示当前存储目录的列表</td></tr><tr><td>disown</td><td>从进程作业表中刪除指定的作业</td></tr><tr><td>&#x3D;&#x3D;echo&#x3D;&#x3D;</td><td>将指定字符串输出到 STDOUT</td></tr><tr><td>enable</td><td>启用或禁用指定的内建shell命令</td></tr><tr><td>eval</td><td>将指定的参数拼接成一个命令，然后执行该命令</td></tr><tr><td>exec</td><td>用指定命令替换 shell 进程</td></tr><tr><td>&#x3D;&#x3D;exit&#x3D;&#x3D;</td><td>强制 shell 以指定的退出状态码退出</td></tr><tr><td>export</td><td>设置子 shell 进程可用的变量</td></tr><tr><td>fc</td><td>从历史记录中选择命令列表</td></tr><tr><td>fg</td><td>将作业以前台模式运行</td></tr><tr><td>getopts</td><td>分析指定的位置参数</td></tr><tr><td>hash</td><td>查找并记住指定命令的全路径名</td></tr><tr><td>help</td><td>显示帮助文件</td></tr><tr><td>history</td><td>显示命令历史记录</td></tr><tr><td>jobs</td><td>列出活动作业</td></tr><tr><td>kill</td><td>向指定的进程 ID(PID) 发送一个系统信号</td></tr><tr><td>let</td><td>计算一个数学表达式中的每个参数</td></tr><tr><td>local</td><td>在函数中创建一个作用域受限的变量</td></tr><tr><td>logout</td><td>退出登录 shell</td></tr><tr><td>mapfile</td><td>从 STDIN 读取数据行，并将其加入索引数组</td></tr><tr><td>popd</td><td>从目录栈中删除记录</td></tr><tr><td>printf</td><td>使用格式化字符串显示文本</td></tr><tr><td>pushd</td><td>向目录栈添加一个目录</td></tr><tr><td>pwd</td><td>显示当前工作目录的路径名</td></tr><tr><td>&#x3D;&#x3D;read&#x3D;&#x3D;</td><td>从 STDIN 读取一行数据并将其赋给一个变量</td></tr><tr><td>readarray</td><td>从 STDIN 读取数据行并将其放入索引数组</td></tr><tr><td>readonly</td><td>从 STDIN 读取一行数据并将其赋给一个不可修改的变量</td></tr><tr><td>return</td><td>强制函数以某个值退出，这个值可以被调用脚本提取</td></tr><tr><td>set</td><td>设置并显示环境变量的值和 shell 属性</td></tr><tr><td>shift</td><td>将位置参数依次向下降一个位置</td></tr><tr><td>shopt</td><td>打开&#x2F;关闭控制 shell 可选行为的变量值</td></tr><tr><td>source</td><td>读取并执行指定文件中的命令（在当前 shell 环境中）</td></tr><tr><td>suspend</td><td>暂停 Shell 的执行，直到收到一个 SIGCONT 信号</td></tr><tr><td>test</td><td>基于指定条件返回退出状态码 0 或 1</td></tr><tr><td>times</td><td>显示累计的用户和系统时间</td></tr><tr><td>trap</td><td>如果收到了指定的系统信号，执行指定的命令</td></tr><tr><td>type</td><td>显示指定的单词如果作为命令将会如何被解释</td></tr><tr><td>typeset</td><td>声明一个变量或变量类型。</td></tr><tr><td>ulimit</td><td>为系统用户设置指定的资源的上限</td></tr><tr><td>umask</td><td>为新建的文件和目录设置默认权限</td></tr><tr><td>unalias</td><td>刪除指定的别名</td></tr><tr><td>unset</td><td>刪除指定的环境变量或 shell 属性</td></tr><tr><td>wait</td><td>等待指定的进程完成，并返回退出状态码</td></tr></tbody></table><h2 id="alisa内置命令"><a href="#alisa内置命令" class="headerlink" title="alisa内置命令"></a>alisa内置命令</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>alisa 用于给命令创建别名。若该命令且不带任何参数，则显示当前 Shell 进程中的所有别名列表。</p><p><img src="/assets/image-20200630084814561.png" alt="image-20200630084814561"></p><p>上面是系统为了方便命令操作默认将部分命令创建为别名  <code>ll</code> 的命令与<code>ls -l</code>的效果一样,   就是因为ll是别名</p><h3 id="alias别名定义语法"><a href="#alias别名定义语法" class="headerlink" title="alias别名定义语法"></a>alias别名定义语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias 别名=&#x27;命令&#x27;</span><br></pre></td></tr></table></figure><h3 id="unalias-别名删除语法"><a href="#unalias-别名删除语法" class="headerlink" title="unalias 别名删除语法"></a>unalias 别名删除语法</h3><p>删除指定的别名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unalias 别名</span><br></pre></td></tr></table></figure><p>删除当前Shell环境中所有的别名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unalias -a</span><br></pre></td></tr></table></figure><blockquote><p>注意:  以上2种方式删除都是临时删除当前Shell的别名,  如果想永久删除必须去配置文件中手动删除</p></blockquote><h3 id="alias演示"><a href="#alias演示" class="headerlink" title="alias演示"></a>alias演示</h3><p>输出所有进行信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -aux</span><br></pre></td></tr></table></figure><p>给上面的命令起别名为psList, 并使用psList输出</p><p><img src="/assets/image-20200630091546806.png" alt="image-20200630091546806"></p><p>删除psList别名</p><p><img src="/assets/image-20200630091747276.png" alt="image-20200630091747276"></p><h2 id="echo内置命令"><a href="#echo内置命令" class="headerlink" title="echo内置命令"></a>echo内置命令</h2><h3 id="echo命令介绍"><a href="#echo命令介绍" class="headerlink" title="echo命令介绍"></a>echo命令介绍</h3><p>echo 是一个 Shell 内置命令，用于在终端输出字符串，并在最后默认加上换行符</p><h3 id="echo输出语法"><a href="#echo输出语法" class="headerlink" title="echo输出语法"></a>echo输出语法</h3><p>默认输出换行语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 字符串</span><br></pre></td></tr></table></figure><p>输出不换行语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -n  字符串</span><br></pre></td></tr></table></figure><h3 id="输出演示"><a href="#输出演示" class="headerlink" title="输出演示"></a>输出演示</h3><p>1.创建echo1.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch echo1.sh</span><br></pre></td></tr></table></figure><p>2.编辑文件内容并保存</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim echo1.sh</span><br></pre></td></tr></table></figure><p>文件内容</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;hello&quot;</span><br><span class="line">echo &quot;world&quot;</span><br><span class="line">echo -n &quot;itheima &quot;</span><br><span class="line">echo -n &quot;shell &quot;</span><br></pre></td></tr></table></figure><p>3.运行echo1.sh文件观察效果</p><p><img src="/assets/image-20200630094335603.png" alt="image-20200630094335603"></p><p>itheima shell输出为一行</p><h3 id="echo输出转义字符"><a href="#echo输出转义字符" class="headerlink" title="echo输出转义字符"></a>echo输出转义字符</h3><h4 id="n-转义字符"><a href="#n-转义字符" class="headerlink" title="/n 转义字符"></a><code>/n</code> 转义字符</h4><p>用于echo输出字符串非结尾处的换行,  但是默认echo无法解析<code>/n</code> 转义字符</p><p>演示</p><p><img src="/assets/image-20200630100606558.png" alt="image-20200630100606558"></p><h4 id="e-参数"><a href="#e-参数" class="headerlink" title="-e 参数"></a><code>-e</code> 参数</h4><p><code>-e</code> 参数用于解析转义字符</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -e &#x27;字符串中含有转义字符&#x27;</span><br></pre></td></tr></table></figure><p>演示</p><p><img src="/assets/image-20200630100653445.png" alt="image-20200630100653445"></p><h4 id="c-转义字符"><a href="#c-转义字符" class="headerlink" title="/c 转义字符"></a><code>/c</code> 转义字符</h4><p><code>/c</code> 用于强制清除echo的结尾换行输出</p><p>演示</p><p><img src="/assets/image-20200630100953178.png" alt="image-20200630100953178"></p><h2 id="read内置命令"><a href="#read内置命令" class="headerlink" title="read内置命令"></a>read内置命令</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>read 是 Shell 内置命令，用于从标准输入中读取数据并赋值给变量。如果没有进行重定向，默认就是从终端控制台读取用户输入的数据；如果进行了重定向，那么可以从文件中读取数据。</p><blockquote><p>后续Shell重定向讲解</p></blockquote><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">read [-options] [var1 var2 ...]</span><br></pre></td></tr></table></figure><blockquote><p><code>options</code>表示选项，如下表所示；<code>var</code>表示用来存储数据的变量，可以有一个，也可以有多个。</p><p><code>options</code>和<code>var</code>都是可选的，如果没有提供变量名，那么读取的数据将存放到环境变量 REPLY 中。</p></blockquote><p>options支持的参数</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a array</td><td>把读取的数据赋值给数组 array，从下标 0 开始。</td></tr><tr><td>-d delimiter</td><td>用字符串 delimiter 指定读取结束的位置，而不是一个换行符（读取到的数据不包括 delimiter）。</td></tr><tr><td>-e</td><td>在获取用户输入的时候，对功能键进行编码转换，不会直接显式功能键对应的字符。</td></tr><tr><td>&#x3D;&#x3D;-n num&#x3D;&#x3D;</td><td>读取 num 个字符，而不是整行字符。</td></tr><tr><td>&#x3D;&#x3D;-p  prompt&#x3D;&#x3D;</td><td>显示提示信息，提示内容为 prompt。</td></tr><tr><td>-r</td><td>原样读取（Raw mode），不把反斜杠字符解释为转义字符。</td></tr><tr><td>&#x3D;&#x3D;-s&#x3D;&#x3D;</td><td>静默模式（Silent mode），不会在屏幕上显示输入的字符。当输入密码和其它确认信息的时候，这是很有必要的。</td></tr><tr><td>&#x3D;&#x3D;-t seconds&#x3D;&#x3D;</td><td>设置超时时间，单位为秒。如果用户没有在指定时间内输入完成，那么 read 将会返回一个非 0 的退出状态，表示读取失败。</td></tr><tr><td>-u fd</td><td>使用文件描述符 fd 作为输入源，而不是标准输入，类似于重定向。</td></tr></tbody></table><h3 id="示例1：多个变量赋值"><a href="#示例1：多个变量赋值" class="headerlink" title="示例1：多个变量赋值"></a>示例1：多个变量赋值</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>使用 read 命令给多个变量赋值</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1.创建文件read1.sh</p><p>2.编辑文件, 编写read命令提示用户输入多个信息个多个变量赋值,  保存文件</p><p>3.执行read1.sh文件</p><h4 id="演示-4"><a href="#演示-4" class="headerlink" title="演示"></a>演示</h4><p>创建文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch read1.sh</span><br></pre></td></tr></table></figure><p>编辑文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim read1.sh</span><br></pre></td></tr></table></figure><p>read1.sh文件内容</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">read -p &quot;请输入姓名,年龄,爱好: &quot; name age hobby</span><br><span class="line">echo &quot;姓名：$name&quot;</span><br><span class="line">echo &quot;年龄：$age&quot;</span><br><span class="line">echo &quot;爱好：$hobby&quot;</span><br></pre></td></tr></table></figure><p>运行效果</p><p><img src="/assets/image-20200630112030560.png" alt="image-20200630112030560"></p><h3 id="示例2：读取一个字符"><a href="#示例2：读取一个字符" class="headerlink" title="示例2：读取一个字符"></a>示例2：读取一个字符</h3><h4 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h4><p>从终端控制台只读取一个字符</p><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><p>1.创建文件read2.sh文件</p><p>2.编辑文件,编写read命令, 使用<code>-n 1</code> 参数读取一个字符</p><p>3.执行文件</p><h4 id="演示-5"><a href="#演示-5" class="headerlink" title="演示"></a>演示</h4><p>创建文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch read2.sh</span><br></pre></td></tr></table></figure><p>编辑文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim read2.sh</span><br></pre></td></tr></table></figure><p>read2.sh文件内容</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">read -n 1 -p &#x27;请输入一个字符: &#x27; char</span><br><span class="line">printf &#x27;\n&#x27;</span><br><span class="line">echo &#x27;你输入的字符为:&#x27;$char</span><br></pre></td></tr></table></figure><blockquote><p>注意</p><p><code>-n 1</code>只读取一个字符。运行脚本后，只要输入的一个字符，立即读取结束，不用等待用户按下回车键。</p><p><code>printf &#39;\n&#39;</code>语句用于换行，否则 echo 的输出结果会和用户输入的内容位于同一行，不容易区分</p></blockquote><p>运行效果<br><img src="/assets/image-20200630113542863.png" alt="image-20200630113542863"></p><h3 id="示例3：限制时间输入"><a href="#示例3：限制时间输入" class="headerlink" title="示例3：限制时间输入"></a>示例3：限制时间输入</h3><h4 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h4><p>在终端控制台输入时, 设置指定时间内输入密码</p><h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><ol><li>创建文件read3.sh</li><li>编辑文件内容编写, 使用read命令<code>-t seconds  </code> 限制输入时间,  使用<code>-s</code> 静默模式输入密码</li><li>执行文件</li></ol><h4 id="演示-6"><a href="#演示-6" class="headerlink" title="演示"></a>演示</h4><p>创建文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch read3.sh</span><br></pre></td></tr></table></figure><p>编辑文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim read3.sh</span><br></pre></td></tr></table></figure><p>read3.sh文件内容</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">read -t 20 -sp &#x27;请输入密码(20秒内):&#x27; pwd1</span><br><span class="line">printf &#x27;\n&#x27;</span><br><span class="line">read -t 20 -sp &#x27;请再次输入密码(20秒内):&#x27; pwd2</span><br><span class="line">printf &#x27;\n&#x27;</span><br><span class="line">if</span><br><span class="line">        [ $pwd1 == $pwd2 ]</span><br><span class="line">then</span><br><span class="line">        echo &#x27;密码与确认密码一致, 验证通过&#x27;</span><br><span class="line">else</span><br><span class="line">        echo &#x27;密码与确认密码不一致,验证失败&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>执行文件运行效果</p><p><img src="/assets/image-20200630115148158.png" alt="image-20200630115148158"></p><h2 id="exit内置命令"><a href="#exit内置命令" class="headerlink" title="exit内置命令"></a>exit内置命令</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p><code>exit</code> 用于退出当前 Shell 进程结束运行，并返回一个退出状态；使用<code>$?</code>可以接收这个退出状态.</p><p>exit 命令可以接受一个整数值作为参数，代表退出状态。如果不指定，默认状态值是 0。</p><p>一般情况下，退出状态为 0 表示成功，退出状态为非 0 表示执行失败（出错）了。 </p><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><p>正确退出语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><p>错误退出语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit 非0数字  # 介于 0~255 之间的整数，其中只有 0 表示成功，其它值都表示失败</span><br></pre></td></tr></table></figure><h3 id="exit应用场景"><a href="#exit应用场景" class="headerlink" title="exit应用场景"></a>exit应用场景</h3><p>1.结束当前Shell进程</p><p>2.当Shell 进程执行出错退出时，可以返回不同的状态值代表不同的错误</p><blockquote><p>比如打开一个文件时，可以返回1 表示文件不存在，2 表示文件没有读取权限，3 表示文件类型不对。</p></blockquote><h3 id="示例：Shell脚本文件中使用exit退出"><a href="#示例：Shell脚本文件中使用exit退出" class="headerlink" title="示例：Shell脚本文件中使用exit退出"></a>示例：Shell脚本文件中使用exit退出</h3><h4 id="需求-3"><a href="#需求-3" class="headerlink" title="需求"></a>需求</h4><p>编写Shell脚本使用exit 退出,  退出时返回一个非0数字状态值,  执行脚本文件并打印返回状态值</p><h4 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h4><p>1.创建exit.sh文件</p><p>2.编辑exit.sh文件, 使用<code>exit 数字</code> 退出结束当前Shell</p><p>3.执行文件,打印返回状态值</p><h4 id="演示-7"><a href="#演示-7" class="headerlink" title="演示"></a>演示</h4><p>创建文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch exit.sh</span><br></pre></td></tr></table></figure><p>编辑文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim exit.sh</span><br></pre></td></tr></table></figure><p>exit.sh文件内容: 使用<code>exit 数字</code> 退出结束当前Shell</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &#x27;one&#x27;</span><br><span class="line">exit 6</span><br><span class="line">echo &#x27;two&#x27;</span><br></pre></td></tr></table></figure><p>运行效果</p><p><img src="/assets/image-20200630150541964.png" alt="image-20200630150541964"></p><h2 id="declare内置命令"><a href="#declare内置命令" class="headerlink" title="declare内置命令"></a>declare内置命令</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p>declare命令用于声明 shell 变量。可用来声明变量并设置变量的属性，也可用来显示shell函数。若不加上任何参数，则会显示全部的shell变量与函数(与执行set指令的效果相同)。</p><h3 id="declare命令作用"><a href="#declare命令作用" class="headerlink" title="declare命令作用"></a>declare命令作用</h3><p>1.declare设置变量的属性</p><p>2.查看全部Shell变量与函数</p><p>3.实现关联数组变量</p><blockquote><p>不同于普通数组,  关联数组的下标是字符串, 通过字符串下标操作数据</p></blockquote><h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><p>1.declare设置变量的属性语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">declare [+/-][aArxif][变量名称＝设置值]</span><br></pre></td></tr></table></figure><blockquote><p>+&#x2F;- 　“-“可用来指定变量的属性，”+”则是取消变量所设的属性。</p><p>a    设置为普通索引数组</p><p>A    设置为key-value关联数组</p><p>r 　将变量设置为只读,  也可以使用readonly</p><p>x 　设置变量成为环境变量，也可以使用export</p><p>i 　设置为整型变量。</p><p>f     设置为一个函数变量</p></blockquote><p>2.查看全部Shell变量与函数定义语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">declare [-fF]</span><br></pre></td></tr></table></figure><blockquote><p>declare 后无参数, 查询全部Shell变量与函数定义</p><p>-f 　仅查询显示函数定义。</p><p>-F    仅查询显示函数名字</p></blockquote><p>3.实现key-value关联数组变量语法</p><p>关联数组也称为“键值对（key-value）”数组，键（key）也即字符串形式的数组下标，值（value）也即元素值。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">declare -A 关联数组变量名=([字符串key1]=值1 [字符串key2]=值2 ...)</span><br></pre></td></tr></table></figure><blockquote><p>declare也可以用于定义普通数组,  <code>-a</code> 参数创建普通或索引数组   <code>-A</code> 创建关联数组</p><p><code>declare -a 关联数组变量名=(值1 值2 ...)</code>  </p><p><code>declare -a 关联数组变量名=([0]=值1 [1]=值2 ...)</code>  </p></blockquote><p>获取指定key的值</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;关联数组变量名[key]&#125;</span></span><br></pre></td></tr></table></figure><p>获取所有值</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;关联数组变量名[*]&#125; <span class="comment"># 方式1</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;关联数组变量名[@]&#125; <span class="comment"># 方式2</span></span></span><br></pre></td></tr></table></figure><h3 id="示例1：设置变量属性"><a href="#示例1：设置变量属性" class="headerlink" title="示例1：设置变量属性"></a>示例1：设置变量属性</h3><h4 id="需求-4"><a href="#需求-4" class="headerlink" title="需求"></a>需求</h4><p>操作一个变量属性,  设置为整型\ 取消整型\设置为只读等操作</p><h4 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h4><ol><li>使用declare设置一个整型变量并赋值</li><li>取消变量的整型类型, 尝试设置其他类型值尝试</li><li>设置变量只读, 尝试赋值测试</li></ol><h4 id="演示-8"><a href="#演示-8" class="headerlink" title="演示"></a>演示</h4><p><img src="/assets/image-20200630164537518.png" alt="image-20200630164537518"></p><h3 id="示例2：查看当前Shell所有函数名"><a href="#示例2：查看当前Shell所有函数名" class="headerlink" title="示例2：查看当前Shell所有函数名"></a>示例2：查看当前Shell所有函数名</h3><p>查看所有变量与所有函数 </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">declare</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200701093735283.png" alt="image-20200701093735283"></p><p>查看所有函数与定义</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">declare -f</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200701094119327.png" alt="image-20200701094119327"></p><p>查询所有函数名列表</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">declare -F</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200701094553443.png" alt="image-20200701094553443"></p><h3 id="示例3：实现普通索引数组"><a href="#示例3：实现普通索引数组" class="headerlink" title="示例3：实现普通索引数组"></a>示例3：实现普通索引数组</h3><h4 id="需求-5"><a href="#需求-5" class="headerlink" title="需求"></a>需求</h4><p>使用declare定义一普通数组,并获取打印元素数据的值</p><h4 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤"></a>步骤</h4><p>1.创建declare1.sh文件</p><p>2.编辑declare1.sh文件内容,  使用declare定义普通数组数据与打印</p><p>2.执行文件</p><h4 id="演示-9"><a href="#演示-9" class="headerlink" title="演示"></a>演示</h4><p>创建文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch declare1.sh</span><br></pre></td></tr></table></figure><p>编辑文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim declare1.sh</span><br></pre></td></tr></table></figure><p>declare1.sh文件内容</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">declare -a arr1=(1 2 3 aa)</span><br><span class="line">echo $&#123;arr1[1]&#125;</span><br><span class="line">echo $&#123;arr1[*]&#125;</span><br><span class="line"></span><br><span class="line">declare -a arr2=([0]=1 [1]=2  [2]=3  [4]=aa)</span><br><span class="line">echo $&#123;arr2[1]&#125;</span><br><span class="line">echo $&#123;arr2[*]&#125;</span><br><span class="line"></span><br><span class="line">declare -a arr2[3]=4</span><br><span class="line">echo $&#123;arr2[*]&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="/assets/image-20200701101651788.png" alt="image-20200701101651788"></p><h3 id="示例4：实现key-value关联数组"><a href="#示例4：实现key-value关联数组" class="headerlink" title="示例4：实现key-value关联数组"></a>示例4：实现key-value关联数组</h3><h4 id="需求-6"><a href="#需求-6" class="headerlink" title="需求"></a>需求</h4><p>使用declare定义关联数组并打印输出</p><h4 id="演示-10"><a href="#演示-10" class="headerlink" title="演示"></a>演示</h4><p><img src="/assets/image-20200701105943576.png" alt="image-20200701105943576"></p><blockquote><p>注意: 使用参数<code>-A</code>  才是关联数组  , 关联数组无法使用索引获取</p></blockquote><h1 id="Shell运算符"><a href="#Shell运算符" class="headerlink" title="Shell运算符"></a>Shell运算符</h1><h2 id="expr命令"><a href="#expr命令" class="headerlink" title="expr命令"></a>expr命令</h2><h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><p>expr 是 evaluate expressions 的缩写，译为“表达式求值”。Shell expr 是一个功能强大，并且比较复杂的命令，它除了可以实现整数计算，还可以结合一些选项对字符串进行处理，例如计算字符串长度、字符串比较、字符串匹配、字符串提取等, 后续讲解。</p><h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><p>计算语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expr 算术运算符表达式</span><br></pre></td></tr></table></figure><blockquote><p>注意: 运算表达式</p></blockquote><p>获取计算结果赋值给新变量语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">result=`expr 算术运算符表达式`</span><br></pre></td></tr></table></figure><h3 id="演示-11"><a href="#演示-11" class="headerlink" title="演示"></a>演示</h3><p><img src="/assets/image-20200701150021331.png" alt="image-20200701150021331"></p><blockquote><p>注意:  运算符表达式中每个数字与符号之间要有空格</p></blockquote><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><h3 id="算术运算符介绍"><a href="#算术运算符介绍" class="headerlink" title="算术运算符介绍"></a>算术运算符介绍</h3><p>下表列出了常用的算术运算符，假定变量 a 为 1，变量 b 为 2：</p><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加法</td><td align="left"><code>expr $a + $b</code> 结果为 3</td></tr><tr><td align="left">-</td><td align="left">减法</td><td align="left"><code>expr $a - $b</code> 结果为 -1</td></tr><tr><td align="left">*</td><td align="left">乘法</td><td align="left"><code>expr $a \* $b</code> 结果为  2</td></tr><tr><td align="left">&#x2F;</td><td align="left">除法</td><td align="left"><code>expr $b / $a</code> 结果为 2</td></tr><tr><td align="left">%</td><td align="left">取余</td><td align="left"><code>expr $b % $a</code> 结果为 0</td></tr><tr><td align="left">&#x3D;</td><td align="left">赋值</td><td align="left">a&#x3D;$b 将把变量 b 的值赋给 a</td></tr></tbody></table><blockquote><p>四则运算中如果使用了(), 也需要转义 <code>\( 1 + 1 \)</code></p></blockquote><h3 id="算术运算符演示"><a href="#算术运算符演示" class="headerlink" title="算术运算符演示"></a>算术运算符演示</h3><p>operation1.sh脚本代码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">a=1 b=2          # 声明变量a=1和b=2</span><br><span class="line">echo &quot;a=$&#123;a&#125; b=$&#123;b&#125;&quot;</span><br><span class="line">echo &quot;a + b = `expr $a + $b`&quot;</span><br><span class="line">echo &quot;a * b = `expr $a \* $b`&quot;</span><br><span class="line">echo &quot;a - b = `expr $a - $b`&quot;</span><br><span class="line">echo &quot;a * b = `expr $a \* $b`&quot;</span><br><span class="line">echo &quot;b / a = `expr $b / $a`&quot;</span><br><span class="line">echo &quot;b % a = `expr $b % $a`&quot;</span><br><span class="line"></span><br><span class="line">echo -n &quot;a == b 结果为 &quot;</span><br><span class="line">if [ $a == $b ]       # 注意变量与符号之间都要有空格</span><br><span class="line">then</span><br><span class="line">        echo true</span><br><span class="line">else</span><br><span class="line">        echo false</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo -n &quot;a != b 结果为 &quot;</span><br><span class="line">if [ $a != $b ]        # 注意变量与符号之间都要有空格</span><br><span class="line">then</span><br><span class="line">        echo true</span><br><span class="line">else</span><br><span class="line">        echo false</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200701145757594.png" alt="image-20200701145757594"></p><blockquote></blockquote><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><h3 id="整数比较运算符"><a href="#整数比较运算符" class="headerlink" title="整数比较运算符"></a>整数比较运算符</h3><h4 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h4><p>下表列出了常用的比较运算符，假定变量 a 为 1，变量 b 为 2：</p><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left"><code>-eq</code></td><td align="left">equals 检测两个数是否相等，相等返回 0, 否则返回1。</td><td align="left"><code>[ $a -eq $b ]</code> 返回 1。</td></tr><tr><td align="left"><code>-ne</code></td><td align="left">not equals检测两个数是否不相等，不相等返回 true。</td><td align="left"><code>[ $a -ne $b ]</code> 返回 0。</td></tr><tr><td align="left"><code>-gt</code></td><td align="left">greater than检测左边的数是否大于右边的,<br>是返回0, 否则1</td><td align="left"><code>[ $a -gt $b ]</code> 返回 1。</td></tr><tr><td align="left"><code>-lt</code></td><td align="left">lower than检测左边的数是否小于右边的,<br>是返回0, 否则1</td><td align="left"><code>[ $a -lt $b ]</code> 返回 0。</td></tr><tr><td align="left"><code>-ge</code></td><td align="left">greater equals检测左边的数是否大于等于右边的,<br>是返回0, 否则1</td><td align="left"><code>[ $a -ge $b ] </code>返回 1。</td></tr><tr><td align="left"><code>-le</code></td><td align="left">lower equals检测左边的数是否小于等于右边的,<br>是返回0, 否则1</td><td align="left"><code>[ $a -le $b ] </code>返回 0。</td></tr><tr><td align="left"><code>&lt;</code></td><td align="left">检测左边的数是否小于右边的,<br/>是返回0, 否则1</td><td align="left"><code>(($a&lt;$b))</code> 返回0</td></tr><tr><td align="left"><code>&lt;=</code></td><td align="left">检测左边的数是否小于等于右边的,<br/>是返回0, 否则1</td><td align="left"><code>(($a&lt;=$b))</code> 返回0</td></tr><tr><td align="left"><code>&gt;</code></td><td align="left">检测左边的数是否大于右边的,<br/>是返回0, 否则1</td><td align="left"><code>(($a&gt;$b))</code> 返回1</td></tr><tr><td align="left"><code>&gt;=</code></td><td align="left">检测左边的数是否大于等于右边的,<br/>是返回0, 否则1</td><td align="left"><code>(($a&gt;=$b))</code> 返回1</td></tr></tbody></table><blockquote><p>注意: 整数比较运算符只支持整数，不支持小数与字符串(字符串比较后续讲解)，除非字符串的值是整数数字。</p><p>每个命令都有返回值,  这个后面我们会讲解退出状态再具体说明,  返回0代表成功, 返回1代表失败</p></blockquote><h4 id="演示-12"><a href="#演示-12" class="headerlink" title="演示"></a>演示</h4><p>operation2.sh脚本代码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">a=1 b=2</span><br><span class="line">echo &quot;a=$&#123;a&#125; b=$&#123;b&#125;&quot;</span><br><span class="line">if [ $a -eq $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -eq $b : a 等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -eq $b: a 不等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -ne $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -ne $b: a 不等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -ne $b : a 等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -gt $b: a 大于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -gt $b: a 不大于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -lt $b: a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -lt $b: a 不小于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -ge $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -ge $b: a 大于或等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -ge $b: a 小于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -le $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -le $b: a 小于或等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -le $b: a 大于 b&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if (($a &gt; $b))</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a &gt; $b: a 大于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a &gt; $b: a 不大于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if (($a &lt; $b))</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a &lt; $b: a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a &lt; $b: a 不小于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if (($a &gt;= $b))</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a &gt;= $b: a 大于或等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a &gt;= $b: a 小于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if (($a &lt;= $b))</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a &lt;= $b: a 小于或等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a &lt;= $b: a 大于 b&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>运行效果</p><p><img src="/assets/image-20200704084311714.png" alt="image-20200704084311714"></p><h3 id="字符串比较运算符"><a href="#字符串比较运算符" class="headerlink" title="字符串比较运算符"></a>字符串比较运算符</h3><h4 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h4><p>可以比较2个变量, 变量的类型可以为数字（整数，小数）与字符串</p><h4 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h4><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p><p>字符串比较可以使用 <code>[[]]</code> 和 <code>[]</code> 2种方式</p><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">&#x3D;&#x3D; 或 &#x3D;</td><td align="left">相等。用于比较两个字符串或数字，相同则返回 0。可以使用<code>=</code></td><td align="left"><code>[ $a == $b ] </code>返回1 <br><code>[  $a = $b ]</code> 返回 1<br><code>[[ $a == $b ]]</code> 返回1<br><code>[[ $a = $b ]]</code> 返回1</td></tr><tr><td align="left">!&#x3D;</td><td align="left">不相等。用于比较两个字符串或数字，不相同则返回 0。</td><td align="left"><code>[ $a != $b ]</code> 返回 0<br><code>[[ $a != $b ]]</code> 返回 0</td></tr><tr><td align="left">&lt;</td><td align="left">小于, 用于比较两个字符串或数字， 小于返回0， 否则返回1</td><td align="left"><code>[ $a \&lt; $b ]</code> 返回 0<br/><code>[[ $a &lt; $b ]]</code> 返回 0</td></tr><tr><td align="left">&gt;</td><td align="left">大于, 用于比较两个字符串或数字， 大于返回0， 否则返回1</td><td align="left"><code>[ $a \&gt; $b ]</code> 返回 1<br/><code>[[ $a &gt; $b ]]</code> 返回 1</td></tr><tr><td align="left">-z</td><td align="left">检测字符串长度是否为0，为0返回 true。</td><td align="left">[ -z $a ] 返回 1。</td></tr><tr><td align="left">-n</td><td align="left">检测字符串长度是否不为 0，不为 0 返回 true。</td><td align="left">[ -n “$a” ] 返回 0。</td></tr><tr><td align="left">$</td><td align="left">检测字符串是否不为空，不为空返回 0 ,否则返回1。</td><td align="left">[ $a ] 返回 0。</td></tr></tbody></table><blockquote><p>字符串比较没有 <code>&lt;=</code>  可以通过 <code>[[ &quot;a&quot; &lt; &quot;b&quot; &amp;&amp; &quot;a&quot; = &quot;b&quot; ]]</code></p></blockquote><h4 id="演示-13"><a href="#演示-13" class="headerlink" title="演示"></a>演示</h4><p>operation6.sh脚本代码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=&quot;itheima&quot; b=&quot;itcast&quot; c=1 d=2</span><br><span class="line">echo &quot;a=$&#123;a&#125;,b=$&#123;b&#125;,c=$&#123;c&#125;,d=$&#123;d&#125;&quot;</span><br><span class="line"></span><br><span class="line">if [ $a = $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a = $b : a 等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a = $b: a 不等于 b&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $a != $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a != $b : a 不等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a != $b: a 等于 b&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $a &gt; $b ]]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a &gt; $b : a 大于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a &gt; $b: a 不大于 b&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $a \&gt; $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a &gt; $b : a 大于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a &gt; $b: a 不大于 b&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $c &gt; $d ]]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$c &gt; $d : c 大于 d&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$c &gt; $d: c 不大于 d&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -z $a ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;-z $a : 字符串长度为 0&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;-z $a : 字符串长度不为 0&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -n &quot;$a&quot; ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;-n $a : 字符串长度不为 0&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;-n $a : 字符串长度为 0&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $a ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a : 字符串不为空&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a : 字符串为空&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>运行效果</p><p><img src="/assets/image-20200704110751421.png" alt="image-20200704110751421"></p><h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="[[]]  和 [] 的区别"></a><code>[[]]</code>  和 <code>[]</code> 的区别</h3><h4 id="区别1-word-splitting的发生"><a href="#区别1-word-splitting的发生" class="headerlink" title="区别1: word splitting的发生"></a>区别1: word splitting的发生</h4><h5 id="区别说明"><a href="#区别说明" class="headerlink" title="区别说明"></a>区别说明</h5><p><code>[[]]</code> 不会有word splitting发生</p><p><code>[]</code> 会有word splitting发生</p><h5 id="word-splitting介绍"><a href="#word-splitting介绍" class="headerlink" title="word splitting介绍"></a>word splitting介绍</h5><p>会将含有空格字符串进行分拆分割后比较</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p><img src="/assets/image-20200704092823470.png" alt="image-20200704092823470"></p><blockquote><p>通过 <code>$?</code>  获取上一个命令的退出状态, 0代表成功, 1代表失败</p></blockquote><h4 id="区别2-转义字符"><a href="#区别2-转义字符" class="headerlink" title="区别2: 转义字符"></a>区别2: 转义字符</h4><h5 id="区别说明-1"><a href="#区别说明-1" class="headerlink" title="区别说明"></a>区别说明</h5><p><code>[[]]</code>  对 <code>&lt;</code> 不需要转义, 格式为 <code> [[ 字符串1 &lt; 字符串2 ]]</code></p><p><code>[]</code> 需要对 <code>&lt;,&gt;等</code> 转义 ,  格式为 <code> [ 字符串1 \&lt; 字符串2 ]</code></p><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p><code>[]</code> 执行效果</p><p><img src="/assets/image-20200704100701687.png" alt="image-20200704100701687"></p><p><code>[[]]</code> 执行效果, 不需要转义执行结果正确</p><p><img src="/assets/image-20200704100843230.png" alt="image-20200704100843230"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li><p>了解有哪些比较运算符</p><p>整数比较运算符</p><blockquote><p>比较方式: <code>[]</code> 和 <code>(())</code></p></blockquote><blockquote><p>方式1: <code>[  整数1 options 整数2 ]</code></p><p><code>options:  -eq  -gt -ge -lt -le -ne</code></p><p>方式2: <code>((整数1 options 整数2))</code></p><p><code>options: &lt; &lt;= &gt; &gt;=</code></p></blockquote><p>字符串,数字比较运算符</p><blockquote><p>介绍: 可以比较2个变量, 变量的类型可以为字符串, 数字(整数,小数)</p><p>比较方式: <code>[]</code> 和 <code>[[]]</code></p></blockquote><blockquote><p>方式1:  <code>[  变量1 options 整数2 ]</code></p><p>​<code>options:  &lt;,&gt;,==,=,!=</code> </p><p>​<code>&lt;,&gt;</code> 需要转义</p><p>​     比较含有空格的字符串, 需要使用””号括起来, 否则会分割拆分</p><p>方式2: <code>[[ 变量1 options 变量2]]</code></p><p>​<code>options:  &lt;,&gt;,==,=,!=</code> </p><p>​<code>&lt;,&gt;</code> 不需要转义</p></blockquote></li><li><p>推荐使用哪个比较运算符?</p><p><code>[[ 表达式 ]]</code>  即可以实现数字和字符串比较,  并且不需要转义, 不会分割</p></li></ol><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><h3 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍"></a>介绍</h3><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">!</td><td align="left">非运算，取反, 表达式为 true 则返回 false，<br>否则返回 true。</td><td align="left"><code>[ ! false ]</code> 返回 true。</td></tr><tr><td align="left">-o</td><td align="left">or 或运算，有一个表达式为 true 则返回 true。</td><td align="left"><code>[ 表达式1 -o 表达式2 ]</code> 返回 true。</td></tr><tr><td align="left">-a</td><td align="left">and 与运算，两个表达式都为 true 才返回 true。</td><td align="left"><code>[ 表达式1 -a 表达式2 ]</code> 返回 false。</td></tr></tbody></table><blockquote><p>注意布尔运算符只能放在<code>[]</code>  才有效  </p><p>以后常使用布尔运算符与test命令进行连接条件测试, 后续讲解</p></blockquote><h3 id="演示-14"><a href="#演示-14" class="headerlink" title="演示"></a>演示</h3><p>operation4.sh脚本代码脚本代码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">a=1 b=2</span><br><span class="line"></span><br><span class="line">if [ $a -lt 2 -a $b -gt 10 ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a 小于 2 且 $b 大于 10 : 返回 true&quot;   </span><br><span class="line">else</span><br><span class="line">   echo &quot;$a 小于 2 且 $b 大于 10 : 返回 false&quot;  # $b -gt 10不成立, 输出这个表达式</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $a -lt 10 -o $b -gt 10 ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a 小于 10 或 $b 大于 10 : 返回 true&quot;  # $a -lt 10 成立, 输出这个表达式</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a 小于 10 或 $b 大于 10 : 返回 false&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ ! $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a 大于 $b 取反 : 返回 true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a 大于 $b 取反 : 返回 false&quot;   # $a -gt $b 为true , 取反为false, 输出这个表达式</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>运行效果</p><p><img src="/assets/image-20200701170127507.png" alt="image-20200701170127507"></p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><h3 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍"></a>介绍</h3><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">逻辑的 AND</td><td align="left"><code>[[ 表达式1 &amp;&amp; 表达式2 ]]</code> 返回 false</td></tr><tr><td align="left">||</td><td align="left">逻辑的 OR</td><td align="left">&#96;[[ 表达式1</td></tr></tbody></table><blockquote><p>注意:  使用<code>&amp;&amp;</code>  和  <code>||</code>  的运算符必须放在 <code>[[]]</code>  或 <code>(())</code>中才有效, 否则报错</p><p> <code>-a</code> 和 <code>-o</code> 的运算符必须放在 <code>[]</code> 在才有效 或 test命令中</p><p>!可以用在<code>[]</code>,<code>[[]]</code>中, 不可以在(())</p></blockquote><h3 id="演示-15"><a href="#演示-15" class="headerlink" title="演示"></a>演示</h3><p>operation5.sh脚本代码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=1 b=2</span><br><span class="line"></span><br><span class="line">if [[ $a -lt 10 &amp;&amp; $b -gt 10 ]]</span><br><span class="line">then</span><br><span class="line">   echo &quot;返回 true&quot; </span><br><span class="line">else</span><br><span class="line">   echo &quot;返回 false&quot;  # $b -gt 10 不成立, 输出false</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $a -lt 10 || $b -gt 10 ]]</span><br><span class="line">then</span><br><span class="line">   echo &quot;返回 true&quot;   # $a -lt 10 成立,  输出true</span><br><span class="line">else</span><br><span class="line">   echo &quot;返回 false&quot;  </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>运行效果</p><p><img src="/assets/image-20200701172201560.png" alt="image-20200701172201560"></p><h2 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h2><h3 id="介绍-12"><a href="#介绍-12" class="headerlink" title="介绍"></a>介绍</h3><p>文件测试运算符用于检测文件的各种属性。</p><p>属性检测描述如下：</p><table><thead><tr><th align="left">操作符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">-b file</td><td align="left">检测文件是否是块设备文件，如果是，则返回 true。</td><td align="left">[ -b $file ] 返回 false。</td></tr><tr><td align="left">-c file</td><td align="left">检测文件是否是字符设备文件，如果是，则返回 true。</td><td align="left">[ -c $file ] 返回 false。</td></tr><tr><td align="left">&#x3D;&#x3D;-d file&#x3D;&#x3D;</td><td align="left">directory, 检测文件是否是目录，如果是，则返回 true。</td><td align="left">[ -d $file ] 返回 false。</td></tr><tr><td align="left">&#x3D;&#x3D;-f file&#x3D;&#x3D;</td><td align="left">file, 检测文件是否是普通文件（既不是目录，也不是设备文件）<br>，如果是，则返回 true。</td><td align="left">[ -f $file ] 返回 true。</td></tr><tr><td align="left">-g file</td><td align="left">检测文件是否设置了 SGID 位，如果是，则返回 true。</td><td align="left">[ -g $file ] 返回 false。</td></tr><tr><td align="left">-k file</td><td align="left">检测文件是否设置了粘着位(Sticky Bit)，如果是，<br>则返回 true。</td><td align="left">[ -k $file ] 返回 false。</td></tr><tr><td align="left">-p file</td><td align="left">检测文件是否是有名管道，如果是，则返回 true。</td><td align="left">[ -p $file ] 返回 false。</td></tr><tr><td align="left">-u file</td><td align="left">检测文件是否设置了 SUID 位，如果是，则返回 true。</td><td align="left">[ -u $file ] 返回 false。</td></tr><tr><td align="left">&#x3D;&#x3D;-r file&#x3D;&#x3D;</td><td align="left">read,检测文件是否可读，如果是，则返回 true。</td><td align="left">[ -r $file ] 返回 true。</td></tr><tr><td align="left">&#x3D;&#x3D;-w file&#x3D;&#x3D;</td><td align="left">write,检测文件是否可写，如果是，则返回 true。</td><td align="left">[ -w $file ] 返回 true。</td></tr><tr><td align="left">&#x3D;&#x3D;-x file&#x3D;&#x3D;</td><td align="left">execute, 检测文件是否可执行，如果是，则返回 true。</td><td align="left">[ -x $file ] 返回 true。</td></tr><tr><td align="left">&#x3D;&#x3D;-s file&#x3D;&#x3D;</td><td align="left">size, 检测文件是否为空（文件大小是否大于0）<br>，不为空返回 true。</td><td align="left">[ -s $file ] 返回 true。</td></tr><tr><td align="left">&#x3D;&#x3D;-e file&#x3D;&#x3D;</td><td align="left">exists, 检测文件（包括目录）是否存在，如果是，<br>则返回 true。</td><td align="left">[ -e $file ] 返回 true。</td></tr><tr><td align="left">file1 -nt file2</td><td align="left">new than(nt),  file1是否比file2新</td><td align="left">[ file1 -nt file2 ]</td></tr><tr><td align="left">file1 -ot file2</td><td align="left">old than(ot), file1是否比file2旧</td><td align="left">[ file1 -ot file2 ]</td></tr></tbody></table><p>其他检查符：</p><ul><li>-S: 判断某文件是否 socket。</li><li>-L: link, 检测文件是否存在并且是一个符号链接。</li></ul><p>语法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ options 文件路径字符串]</span><br><span class="line">或</span><br><span class="line">[[ options 文件路径字符串 ]]</span><br></pre></td></tr></table></figure><h3 id="演示-16"><a href="#演示-16" class="headerlink" title="演示"></a>演示</h3><p>operation6.sh脚本代码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">file=&quot;/root/operation1.sh&quot;</span><br><span class="line">if [ -w $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件可写&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不可写&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -r $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件可读&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不可读&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -x $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件可执行&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不可执行&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -f $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件是普通文件&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件是特殊文件&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -s $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件不是空&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件是空&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -e $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件存在&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不存在&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -d $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件是目录&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不是目录&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">file2=&quot;/root/operation2.sh&quot;</span><br><span class="line">if [ file -nt file2 ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;operation1.sh文件比operation2.sh文件新&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;operation1.sh文件不比operation2.sh文件新&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>运行效果</p><p><img src="/assets/image-20200703085454524.png" alt="image-20200703085454524"></p><blockquote><p>operation1.sh文件不可执行, 因为没有可执行权限</p></blockquote><p>查看operation1.sh文件权限</p><p><img src="/assets/image-20200703084825357.png" alt="image-20200703084825357"></p><p>给operation1.sh添加执行权限</p><p><img src="/assets/image-20200703085602758.png" alt="image-20200703085602758"></p><p>重新执行operation6.sh</p><p><img src="/assets/image-20200703085719905.png" alt="image-20200703085719905"></p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象基础部分</title>
      <link href="/archives/c7509fab.html"/>
      <url>/archives/c7509fab.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-面向对象基础部分"><a href="#Java-面向对象基础部分" class="headerlink" title="Java 面向对象基础部分"></a>Java 面向对象基础部分</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是面向对象编程"><a href="#什么是面向对象编程" class="headerlink" title="什么是面向对象编程"></a>什么是面向对象编程</h3><p>形象的理解面向对象编程就是</p><p><img src="https://s3.bmp.ovh/imgs/2022/09/15/e0d23921cc8667dd.png"></p><h2 id="内存机制"><a href="#内存机制" class="headerlink" title="内存机制"></a>内存机制</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Qirui&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        c1.run();</span><br><span class="line">        System.out.println(c1.name);</span><br><span class="line">        <span class="type">Car</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;QQ&quot;</span>,<span class="number">5</span>);</span><br><span class="line">        c2.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Goods</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;启动了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;的价格是&quot;</span>+price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先执行test类，先加载到方法区，Test类中有一个main方法，虚拟机会将main方法提到栈内存中执行，执行main方法中的代码，对于Car类也会被加载到方法区，没有执行时，会加载到栈内存，new后会在堆内存里开辟空间，而由于对象的方法代码可能会很多，占据堆内存空间，故只存储地址，会指向方法区的方法。</p><p><img src="https://s3.bmp.ovh/imgs/2022/09/15/28c07adeceb251d9.png"></p><h2 id="构造器的作用"><a href="#构造器的作用" class="headerlink" title="构造器的作用"></a>构造器的作用</h2><p>用于初始化一个类的对象，并返回对象的地址</p><p><img src="https://s3.bmp.ovh/imgs/2022/09/15/f56b75e048e0b86d.png"></p><h2 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装：告诉我们，如何正确设计对象的方法和属性。</p><p>封装的原则：对象代表什么，就得封装对应的数据，并提供数据对应的行为</p><p>如何进行封装更好：</p><p>1.一般对成员变量使用private关键字进行修饰（private修饰的成员只能在当前类中访问）</p><p>2.为每个成员变量提供public修饰的getter和setter方法暴露其取值和赋值</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><p>实体类，其对象可以用于在程序中封装数据</p><h4 id="书写要求"><a href="#书写要求" class="headerlink" title="书写要求"></a>书写要求</h4><p>1.成员变量用private修饰</p><p>2.为成员提供相应的set（），get（）方法</p><p>3.必须提供一个无参构造器，有参数构造器可写可不写。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">//1、成员变量使用private</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">    <span class="comment">//3.必须要有无参构造器</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">User</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name,<span class="type">double</span> height,<span class="type">double</span> salary)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     2.必须为成员变量提供setter和getter方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getHeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">double</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p><img src="https://s3.bmp.ovh/imgs/2022/09/19/1ccebea44e23fd4d.png"></p><h2 id="String-创建对象的方式"><a href="#String-创建对象的方式" class="headerlink" title="String 创建对象的方式"></a>String 创建对象的方式</h2><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p> 直接用双引号围起来</p><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>new构造器得到的字符串对象</p><h2 id="两种方式的不同"><a href="#两种方式的不同" class="headerlink" title="两种方式的不同"></a>两种方式的不同</h2><p>双引号给出的字符串对象存在于堆内存的常量池中，相同内容只会存储一份，<strong>String是不可变字符串</strong>，new构造器每new一次都会产生一次新内容</p><h1 id="ArrayList-的使用"><a href="#ArrayList-的使用" class="headerlink" title="ArrayList 的使用"></a>ArrayList 的使用</h1><p>集合的特点：集合大小不固定，类型选泽也不固定</p><p>Arraylist集合的对象获取</p><pre><code>         public ArrayList();</code></pre><h2 id="Arraylist-添加元素的方法"><a href="#Arraylist-添加元素的方法" class="headerlink" title="Arraylist 添加元素的方法"></a>Arraylist 添加元素的方法</h2><p>方法：</p><p>public boolean add(E e) 将指定元素追加到集合的末尾</p><p>public void add(int index,E element) 在集合的指定位置插入指定的元素</p><p><em><strong>集合中存储的元素并不是对象本身，而是对象的地址</strong></em></p><h2 id="ArrayList-遍历删除存对象和修改"><a href="#ArrayList-遍历删除存对象和修改" class="headerlink" title="ArrayList 遍历删除存对象和修改"></a>ArrayList 遍历删除存对象和修改</h2><p>for循环遍历</p>]]></content>
      
      
      <categories>
          
          <category> Java面向对象基础部分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面向对象基础部分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树形DP acm练习</title>
      <link href="/archives/566865e9.html"/>
      <url>/archives/566865e9.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=2196">Problem - 2196 (hdu.edu.cn)</a></p><p><a href="https://ac.nowcoder.com/acm/contest/24872/G">G-Edge Groups_第 46 届 ICPC 国际大学生程序设计竞赛亚洲区域赛（上海） (nowcoder.com)</a></p><p><a href="https://codeforces.com/gym/103145/problem/C">Problem - C - Codeforces</a></p>]]></content>
      
      
      <categories>
          
          <category> 树形dp acm练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bitset优化背包</title>
      <link href="/archives/c352e424.html"/>
      <url>/archives/c352e424.html</url>
      
        <content type="html"><![CDATA[<h1 id="bitset优化背包"><a href="#bitset优化背包" class="headerlink" title="bitset优化背包"></a>bitset优化背包</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p> <a href="https://ac.nowcoder.com/acm/problem/17193">简单瞎搞题 (nowcoder.com)</a></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>很明显的分组背包，如果简单分析问题，f[i][j]表示前i个物品，值为j的数能否造出来，如果用常规的dp，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6+10;</span><br><span class="line">bool f[110][N];</span><br><span class="line">int sum,ans;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    f[0][0] = true;</span><br><span class="line">    for(int i = 1;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);</span><br><span class="line">        for(int j = r;j &gt;= l;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int k = sum;k &gt;= 0;k--)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][k + j * j] |= f[i-1][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += r * r;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i &lt;= sum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(f[n][i]) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，数的和最大为1e6，所以空间会受限，而bitset数组的空间是bool空间的1&#x2F;8，所以可以用bitset</p><p>优化空间，而且bitset的count函数正好可以统计哪个数位为1.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">const int N = 1e6 + 10;</span><br><span class="line">bitset&lt;N&gt; f[110];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    f[0][0] = 1;</span><br><span class="line">    for(int i = 1;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);</span><br><span class="line">        for(int j = l;j &lt;= r;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i] |= f[i-1] &lt;&lt; (j * j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n].count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包问题 </tag>
            
            <tag> bitset优化背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022杭电杯第一场 C Backpack(bitset优化背包问题)</title>
      <link href="/archives/5933bb1a.html"/>
      <url>/archives/5933bb1a.html</url>
      
        <content type="html"><![CDATA[<h1 id="2022杭电杯第一场-C-Backpack（bitset优化背包问题"><a href="#2022杭电杯第一场-C-Backpack（bitset优化背包问题" class="headerlink" title="2022杭电杯第一场 C Backpack（bitset优化背包问题)"></a>2022杭电杯第一场 C Backpack（bitset优化背包问题)</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>Alice has a backpack of capacity m<em>m</em> that she now wants to fill with some items!</p><p>Alice has n<em>n</em> items, each of which has a volume v_i<em>v**i</em> and a value w_i<em>w**i</em>.</p><p>Can a number of items be selected from n items such that the backpack is exactly full (ie the sum of the volumes equals the backpack capacity)? If so, what is the maximum XOR sum of the values of the items in the backpack when the backpack is full?</p></blockquote><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><blockquote><p>The first line contains an integer T(T \le 10)<em>T</em>(<em>T</em>≤10) —the number of test cases.</p><p>The first line of each test case contains 2 integers n,m(1 \le n,m &lt; 2^{10})<em>n</em>,<em>m</em>(1≤<em>n</em>,<em>m</em>&lt;210) —the number of items, the capacity of the backpack.</p><p>The next n<em>n</em> lines , each line contains 2 integers v_i,w_i(1 \le v_i,w_i &lt; 2^{10})<em>v**i</em>,<em>w**i</em>(1≤<em>v**i</em>,<em>w**i</em>&lt;210) — the volume and value of the item.</p></blockquote><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><blockquote><p>For each test case, output a single line, if the backpack cannot be filled, just output a line of “-1”, otherwise output the largest XOR sum.</p></blockquote><p>Sample output</p><blockquote><p>1</p><p> 5 4</p><p> 2 4</p><p> 1 6</p><p> 2 2</p><p> 2 12</p><p> 1 14</p></blockquote><p>Sample output</p><blockquote><p>14</p></blockquote><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>很明显的0-1背包，但是还要再多一维状态用来表示异或和</p><p>f(i,j,k)表示前i个物品，异或和为j，体积为k的物品，转移方程为选择第i个物品 f(i-1,j,k-v)和不选择第i个物品f(i-1,j^w,k-v)。</p><p>但是这样直接去循环时间复杂度肯定过不了(0(N^3))，由于体积和价值只有2^10,可以想到使用bitset压位。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int n,m,cnt;</span><br><span class="line"></span><br><span class="line">bitset&lt;1050&gt; f[1050],g[1050];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int j=0;j&lt;1024;++j)&#123;</span><br><span class="line">f[j].reset();</span><br><span class="line">&#125;</span><br><span class="line">f[0][0]=1;</span><br><span class="line">int x,y;</span><br><span class="line">int ans=-1;</span><br><span class="line">for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">for(int j=0;j&lt;1024;++j)&#123;</span><br><span class="line">g[j]=f[j];</span><br><span class="line">g[j]&lt;&lt;=x;//更新体积</span><br><span class="line">&#125;</span><br><span class="line">for(int j=0;j&lt;1024;++j)&#123;</span><br><span class="line">f[j]|=g[j^y];//更新异或和</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int j=0;j&lt;1024;++j)&#123;</span><br><span class="line">if(f[j][m])&#123;</span><br><span class="line">ans=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">std::ios::sync_with_stdio(false);</span><br><span class="line">cin.tie(0);</span><br><span class="line">int t=1;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">for(int i=1;i&lt;=t;++i)&#123;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux入门之tmu vim工具</title>
      <link href="/archives/34095c49.html"/>
      <url>/archives/34095c49.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux入门之tmux-vim"><a href="#Linux入门之tmux-vim" class="headerlink" title="Linux入门之tmux vim"></a>Linux入门之tmux vim</h1><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><p>功能1：分屏</p><blockquote><p>tmux</p><p>Ctrl + b + % 新建一个pane 左右平分</p><p>Ctrl + b + “ 新建一个pane，上下平分</p><p>Ctrl + d 关闭一个pane</p></blockquote><p>功能2：</p><h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p>功能：<br>    (1) 命令行模式下的文本编辑器。<br>    (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。<br>    (3) 使用方式：vim filename<br>        如果已有该文件，则打开它。<br>        如果没有该文件，则打开个一个新的文件，并命名为filename<br>模式：<br>    (1) 一般命令模式<br>        默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。<br>    (2) 编辑模式<br>        在一般命令模式里按下i，会进入编辑模式。<br>        按下ESC会退出编辑模式，返回到一般命令模式。<br>    (3) 命令行模式<br>        在一般命令模式里按下:&#x2F;?三个字母中的任意一个，会进入命令行模式。命令行在最下面。<br>        可以查找、替换、保存、退出、配置编辑器等。<br>操作：<br>    (1) i：进入编辑模式<br>    (2) ESC：进入一般命令模式<br>    (3) h 或 左箭头键：光标向左移动一个字符<br>    (4) j 或 向下箭头：光标向下移动一个字符<br>    (5) k 或 向上箭头：光标向上移动一个字符<br>    (6) l 或 向右箭头：光标向右移动一个字符<br>    (7) n<Space>：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符<br>    (8) 0 或 功能键[Home]：光标移动到本行开头<br>    (9) $ 或 功能键[End]：光标移动到本行末尾<br>    (10) G：光标移动到最后一行<br>    (11) :n 或 nG：n为数字，光标移动到第n行<br>    (12) gg：光标移动到第一行，相当于1G<br>    (13) n<Enter>：n为数字，光标向下移动n行<br>    (14) &#x2F;word：向光标之下寻找第一个值为word的字符串。<br>    (15) ?word：向光标之上寻找第一个值为word的字符串。<br>    (16) n：重复前一个查找操作<br>    (17) N：反向重复前一个查找操作<br>    (18) :n1,n2s&#x2F;word1&#x2F;word2&#x2F;g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2<br>    (19) :1,$s&#x2F;word1&#x2F;word2&#x2F;g：将全文的word1替换为word2<br>    (20) :1,$s&#x2F;word1&#x2F;word2&#x2F;gc：将全文的word1替换为word2，且在替换前要求用户确认。<br>    (21) v：选中文本<br>    (22) d：删除选中的文本<br>    (23) dd: 删除当前行<br>    (24) y：复制选中的文本<br>    (25) yy: 复制当前行<br>    (26) p: 将复制的数据在光标的下一行&#x2F;下一个位置粘贴<br>    (27) u：撤销<br>    (28) Ctrl + r：取消撤销<br>    (29) 大于号 &gt;：将选中的文本整体向右缩进一次<br>    (30) 小于号 &lt;：将选中的文本整体向左缩进一次<br>    (31) :w 保存<br>    (32) :w! 强制保存<br>    (33) :q 退出<br>    (34) :q! 强制退出<br>    (35) :wq 保存并退出<br>    (36) :set paste 设置成粘贴模式，取消代码自动缩进<br>    (37) :set nopaste 取消粘贴模式，开启代码自动缩进<br>    (38) :set nu 显示行号<br>    (39) :set nonu 隐藏行号<br>    (40) gg&#x3D;G：将全文代码格式化<br>    (41) :noh 关闭查找关键词高亮<br>    (42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令<br>异常处理：<br>    每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。<br>    如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：<br>        (1) 找到正在打开该文件的程序，并退出<br>        (2) 直接删掉该swp文件即可</p>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常见文件管理命令大全</title>
      <link href="/archives/34095c49.html"/>
      <url>/archives/34095c49.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux常见文件管理命令"><a href="#Linux常见文件管理命令" class="headerlink" title="Linux常见文件管理命令"></a>Linux常见文件管理命令</h1><p>常见命令介绍</p><blockquote><p> 1.Ctrl c  :取消命令并换行</p><p> 2.Ctrl u :清空本行命令</p><p> 3.ls: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件</p><p>​         ls -a：查看所有文件包括隐藏文件（以.开头的文件就是隐藏文件）</p><p>​ㅤ●ㅤls -l：查看当前路径下文件的读、写、执行权限</p><p>ㅤㅤㅤ●ㅤls | wc -l：查看ls下有多少个文件</p><p>   4.pwd：显示当前路径</p><p>   5.cd XXX: 进入XXX目录下, cd .. 返回上层目录</p><ol start="6"><li><p>cp XXX YYY: 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如..&#x2F;dir_c&#x2F;a.txt，表示上层目录下的dir_c文件夹下的文件a.txt</p></li><li><p>cp XXX YYY -r : 将XXX目录（文件夹）复制到YYY下</p></li><li><p>. rm XXX：删除普通文件； rm XXX -r：删除文件夹</p><p>ㅤㅤㅤ●ㅤ支持正则表达式，删除所有.txt类型文件：rm *.txt</p><p>ㅤㅤㅤ●ㅤ删除所有文件（不包括文件夹）：rm *</p><p>ㅤㅤㅤ●ㅤ正则表达式删除所有文件夹：rm * -r即可</p><p>9.mv XXX YYY：将XXX文件移动到YYY下，和cp命令一样，XXX和YYY可以是同一个路径；重命名也是用这个命令</p><p>ㅤㅤㅤ●ㅤ非当前路径移动方法：mv a.txt ..&#x2F;b.txt</p><p>10.touch XXX：创建一个文件</p><p>11.cat XXX：展示文件XXX中的内容</p><ol start="12"><li><p>复制文本：windows&#x2F;Linux下：Ctrl + insert，Mac下：command + c</p></li><li><p>粘贴文本：windows&#x2F;Linux下：Shift + insert，Mac下：command + v</p></li><li><p>history：查看历史输入指令</p></li><li><p>tree：以树形显示文件目录结构</p></li></ol></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codeforces round#819</title>
      <link href="/archives/bed3a285.html"/>
      <url>/archives/bed3a285.html</url>
      
        <content type="html"><![CDATA[<h1 id="codeforces-round-819"><a href="#codeforces-round-819" class="headerlink" title="codeforces round 819"></a>codeforces round 819</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>题目链接：<a href="https://codeforces.com/contest/1726/problem/A">Mainak and Array</a></p><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给定一个长度为n数组，你仅有一次机会旋转一个子区间，最大化a[n] - a[1]。</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>可以分类讨论一下：</p><p>1.对于位置 i  可以将它自己旋转到n的位置，那么 i+1就作为 1的位置</p><p>2.固定a[1]不变，旋转使得a[n]最大</p><p>3.固定a[n]不变，旋转使得a[1]最小</p><p>思路很简单。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10100</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(a[n] - a[<span class="number">1</span>],ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i++)<span class="comment">//枚举每个数作为a[n]</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,a[i] - a[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i++) <span class="comment">//枚举除1位置上的数作为a[n]</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,a[i] - a[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,a[n] - a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p><a href="https://codeforces.com/contest/1726/problem/B">Mainak and Interesting Sequence</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为n，所有数的和为m的数组，回答是否能够构造出一个有趣的数组。对于数组p, p[i] 的值 为 a数组中所有严格小于a[i]的数的异或和。一个有趣的数组应满足所有的p[i] &#x3D; 0。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>考察异或的性质：如果两个相同的数异或，值为0</p><p>那我们可以构造一个数组，当n是偶数时，若m为偶数，那么可以 构造一个包含 n - 2个1 和 2个 m - (n-2) &#x2F; 2。若m为奇数则无解，因为我们构造不出来使得 m - n + 2为偶数。当n为奇数时，可以构造一个包含 n - 1个1，和 一个 m - n + 1.</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    if(n == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n &gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n % 2 == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if(m % 2 == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">        for(int i = 1;i &lt;= n - 2;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;1&lt;&lt;&quot; &quot;;</span><br><span class="line">            m -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;m / 2&lt;&lt;&quot; &quot;&lt;&lt;m / 2&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    else </span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">        for(int i = 1;i &lt;= n - 1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;1&lt;&lt;&quot; &quot;;</span><br><span class="line">            m -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>链接： <a href="https://codeforces.com/contest/1726/problem/C">Jatayu’s Balanced Bracket Sequence</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定n对括号，是一个长度为2n的合法括号序列。一个区间[l, r]如果是一个合法序列，那么l和r之间会有一条边，求该图的连通块数量。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>思维题，主要是分析好对于什么情况会产生两个连通块：连续两个(才会增加一个联通块，因为这两个(各自匹配的括号不可能联通，所以只需要统计两个 ( 相连 的情况。但是要注意的是1和n肯定会产生一个连通块，所以ans一开始要设为1</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char s[1010000];</span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d%s&quot;,&amp;n,s+1);</span><br><span class="line">    int ans = 1;</span><br><span class="line">    for(int i = 2;i &lt;= n * 2;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i] == &#x27;(&#x27; &amp;&amp; s[i-1] == &#x27;(&#x27;) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p>题目链接：<a href="https://codeforces.com/contest/1726/problem/D">Edge Split</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定一个无向图，其中边的数量小于等于n + 2，给所有的m条边染色，使得对于每种颜色的边连通块数量之和最小。</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>如果没有环的话,那么每条边都会使连通分量数减少,所以我们的目标是不让构造的图里出现环。而且m的数据范围是&lt;&#x3D;n + 2的，所以可以想到构造一棵生成树染成一种颜色，然后最多还有三条边。如果这三条边没有成环直接输出，如果这三条边出现了环，那么就任取一条环上的边，并取这条边<strong>深度较大</strong>的节点，用这个点在生成树上的父亲边替换选取的环上的边。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+10;</span><br><span class="line">int ans[N],b[N],f[N],dep[N];</span><br><span class="line">int fa[N];</span><br><span class="line">int u[N],v[N];</span><br><span class="line">vector&lt;int&gt; e[N];</span><br><span class="line">void init(int n)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 1;i &lt;= n;i++) f[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x != f[x]) f[x] = find(f[x]);</span><br><span class="line">    return f[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">    for(auto s : e[u])</span><br><span class="line">    &#123;</span><br><span class="line">        if(s == fa[u]) continue;</span><br><span class="line">        fa[s] = u;</span><br><span class="line">        dep[s] = dep[u] + 1;</span><br><span class="line">        dfs(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    iota(f+1,f+1+n,1);</span><br><span class="line">    for(int i = 1;i &lt;= n + 2;i++) ans[i] = fa[i] = b[i] = 0,dep[i] = 0,e[i].clear();</span><br><span class="line">    //  memset(f,0,sizeof f);</span><br><span class="line">    //memset(dep,0,sizeof dep);</span><br><span class="line">    int id = 0;</span><br><span class="line">    for(int i = 1;i &lt;= m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u[i]&gt;&gt;v[i];</span><br><span class="line">        if(find(u[i]) != find(v[i])) </span><br><span class="line">        &#123;</span><br><span class="line">            f[find(u[i])] = find(v[i]);</span><br><span class="line">            ans[i] = 1;</span><br><span class="line">            e[u[i]].push_back(v[i]);</span><br><span class="line">            e[v[i]].push_back(u[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(m == n + 2)//有可能成环</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = 1;i &lt;= m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(ans[i]) continue;</span><br><span class="line">            id = i;//选取一条边</span><br><span class="line">            b[u[i]] = b[v[i]] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for(int i = 1;i &lt;= n;i++) if(b[i]) cnt++;//判断是否成环</span><br><span class="line">        if(cnt == 3)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(1);</span><br><span class="line">            if(dep[v[id]] &lt; dep[u[id]]) swap(v[id],u[id]);//确保选取的边深度最大的点是v[id]</span><br><span class="line">            for(int i = 1;i &lt;= m;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(u[i] == v[id] &amp;&amp; v[i] == fa[v[id]])  swap(ans[id],ans[i]);</span><br><span class="line">                else if(v[i] == v[id] &amp;&amp; u[i] == fa[v[id]]) swap(ans[id],ans[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1;i &lt;= m;i++) cout&lt;&lt;ans[i]; </span><br><span class="line">    cout&lt;&lt;&#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(0);</span><br><span class="line">cin.tie(0);cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Acwing 100 题解</title>
      <link href="/archives/3b534ab8.html"/>
      <url>/archives/3b534ab8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Acwing100-题解"><a href="#Acwing100-题解" class="headerlink" title="Acwing100 题解"></a>Acwing100 题解</h1><p>原题链接： <a href="https://www.acwing.com/problem/content/102/">https://www.acwing.com/problem/content/102/</a></p><p><strong>1.<strong>首先我们先要知道的是用差分的思想，每次对差分数组的两个点做加或减的操作，最后使得b[2]到b[n]都为0,。<br>疑点一：为什么是从2到n而不是从1到n：<br>我们可以回想一下差分数组是怎么来的，是原始数组a[i]减去a[i-1];那么b[1]呢，b[1]是不是就等于a[1],(a[0]&#x3D;0)<br>所以如果这个数列的值都是一样的，</strong>最后我们的差分数组一定是b[1] &#x3D; 一个常数，b[2]-b[n] 都等于0</strong>（这个点在求数列种数的时候也会用到）</p><hr><p><strong>2</strong>.如何保证操作次数最小：<br>一个数列可能有负数也可能有正数，利用贪心的思想 差分数组数组的操作b[l] +&#x3D; 1,b[r+1] -&#x3D; 1的特性可以使正负两个数相消，所以最后差分就只剩同符号的数，此时操作数为min(pos,neg)&#x2F;&#x2F;pos为差分数组中正数和，neg为负数和。剩下的同符号的数只能通过b[1]或者b[n+1]两个对差分数组没有影响的来一个一个的把自己减为0，<br>所以操作次数为个数的总和，abs(pos-neg);</p><hr><p>3.种类数量为什么是abs(pos-neg)+1<br>根据疑点一最后得出来的性质我们可以想到数列的值就是b[1]的值，因为根据逆推，原数组(也就是我们的数列)是差分数组的前缀和，根据前缀和的公式，s[i] &#x3D; s[i-1] + b[i];由于b[2]-b[n]都为0，故s[i] &#x3D; s[i-1] &#x3D; b[1]；所以我们对b[1]的操作次数也就是种类数量，由于贪心的去操作，我们一开始是对负数和正数两个点进行操作，所以b[1]没有变，之后数组就只剩下同符号的数，此时我们有两种方案，假设此时数组只剩下正数，方案一1.b[1] +&#x3D; 1,b[i+1] -&#x3D;1<br>方案2.b[i] -&#x3D; (-1),b[n+1] +&#x3D; (-1);<br>因为最后的效果相同均是将2-n的数减为0，故两种方案均可，举例两个边界情况，如果只采取方案二，b[1]不变，如果只采取方案一，即需要操作abs(pos-neg)次，b[1] +&#x3D; abs(pos-neg);我们可以假设一开始b[1]为2，abs(pos-neg)为3，b[1]的取值可能为2,3,4,5，即abs(pos-neg)+1  </p><h3 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N  = 1e5+10;</span><br><span class="line">int b[N],a[N];</span><br><span class="line">long long pos,neg;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i = 1;i &lt;= n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        b[i] = a[i] - a[i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 2;i &lt;= n;i++)&#123;</span><br><span class="line">        if(b[i] &gt; 0) pos += b[i];</span><br><span class="line">        else  neg -=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;min(pos,neg)+abs(pos-neg)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;abs(pos-neg) + 1;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 差分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 差分 </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树形动态规划(一)</title>
      <link href="/archives/a0ab2bd9.html"/>
      <url>/archives/a0ab2bd9.html</url>
      
        <content type="html"><![CDATA[<h1 id="树形动态规划入门（一）树上背包"><a href="#树形动态规划入门（一）树上背包" class="headerlink" title="树形动态规划入门（一）树上背包"></a>树形动态规划入门（一）树上背包</h1><h2 id="例题（1）"><a href="#例题（1）" class="headerlink" title="例题（1）"></a>例题（1）</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一个 n(1≤n≤2000)n(1≤n≤2000) 个点的有根树，其中1号点为根。每个点有一个权值ai(−105≤ai≤105)，权值可能是负数。</p><p>你需要回答 q(1≤q≤105) 个询问，在 u 的子树中，选择一个大小恰好为 m(1≤m≤n) 的包含 u 点的连通块，最大的权值和。保证 m 不会超过 u 的子树大小。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以用f[i][j]表示前i个节点选了j个节点的权值和，那么对于当前节点我们可以考虑将它的某些子节点合并成一个连通块，</p><p>由于n的数据范围只有2000，我们可以考虑枚举，将问题分为两类，一类是sz[u]，表示dfs过的子树里，一类是sz[v]，表示目前要考虑合并的子节点，那么合并的个数就是sz[u]的子集和sz[v]的子集。</p><p>我们这里指的合并并不是要真的合并，而是用一个tmp数组，下标表示已合并的个数，存储权值的最大值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2100</span>, M = N, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> w[N], f[N][N], sz[N];</span><br><span class="line"><span class="type">int</span> tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">0</span>;</span><br><span class="line">    f[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt;= sz[u] + sz[j]; v ++ ) tmp[v] = -INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= sz[u]; k ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt;= sz[j]; v ++ )</span><br><span class="line">                tmp[k + v] = <span class="built_in">max</span>(tmp[k + v], f[u][k] + f[j][v]);</span><br><span class="line">        sz[u] += sz[j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt;= sz[u]; v ++ ) f[u][v] = tmp[v];</span><br><span class="line">        <span class="comment">//if (u == 2) cout &lt;&lt; f[u][2] &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    sz[u] += <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//if (u == 4) cout &lt;&lt; sz[u] &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = sz[u]; i &gt;= <span class="number">1</span>; i -- ) f[u][i] = f[u][i - <span class="number">1</span>] + w[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="built_in">add</span>(x, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; f[1][2] &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="comment">//cout &lt;&lt;x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[x][y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-（2）树上背包（二）"><a href="#例题-（2）树上背包（二）" class="headerlink" title="例题 （2）树上背包（二）"></a>例题 （2）树上背包（二）</h2><blockquote><p>给你一个n(1≤n≤50000) 个点的有根树，其中1号点为根。每个点有一个权值ai(−105≤ai≤105)，权值可能是负数。</p><p>你需要回答 q(1≤q≤105) 个询问，在 u的子树中，选择一个大小恰好为 m(1≤m≤100) 的包含 u 点的连通块，最大的权值和。保证 m 不会超过 u 的子树大小。</p></blockquote><p>这题与例题一的不同是n的范围变大了，但是因为给了m的范围，所以第二维的范围只要求[1,100]的最大值即可，时间复杂度为O（nm）。所以只需要注意在循环（1，sz[u])的时候，取min（m,sz[u]）即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="树上背包（三）"><a href="#树上背包（三）" class="headerlink" title="树上背包（三）"></a>树上背包（三）</h2><blockquote><p>给你一个 n(1≤n≤1000) 个点的有根树，其中1号点为根。每个点有一个权值 ai(1≤ai≤10e5) 和重量wi(1≤wi≤104)。你需要选择一个重量恰好 k 的包含根的连通块，最大的权值和。对所有的k&#x3D;0,1,2,…,m输出答案，其中 1≤m≤10e4 。如果不存在，输出<code>0</code>。</p></blockquote><p>包含根的连通块：如果当前点被选择了，那么它的祖先都要被选择 </p><p>还是设计状态： f[i][j] 表示在i这个子树中选择了重量等于j，并且包含i这个点的连通块最大的权值和，但是重量的状态是O（m）的,时间复杂度肯定不能满足。</p><p>这里介绍一个非常特殊的技巧，在DFS序上做DP。</p><p>什么是DFS序： 就是可以看作对这棵树做一遍DFS，遍历节点的顺序</p><p>令r(x)表示DFS序中跳过x这个子树的下一个位置</p><p>从后往前推 ，令f[i][j]表示DFS序中[i,n]这一段的节点，所选重量和为j的最大权值和</p><p>🌿tips:</p><blockquote><p>为什么要从后往前倒序遍历：因为dfs序中对于当前节点i的子节点是i+1,因此我们要先确定i+1的状态</p></blockquote><p>我们可以推一下转移方程，如w果不选这个节点，那么当前子树就会被跳过，因为我们不可能跳过子树的根节点，那么当前这个点就是由i这个子树的下一个位置转移过来的 f[r(i)][j]。</p><p>如果选这个节点，那么就是简单的线性dp  : f[i+1][j-w ] + v。</p>]]></content>
      
      
      <categories>
          
          <category> 树形动态规划基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 树上问题 </tag>
            
            <tag> 树形DP </tag>
            
            <tag> 树上背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存分配介绍</title>
      <link href="/archives/9a7c0487.html"/>
      <url>/archives/9a7c0487.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java内存分配介绍"><a href="#Java内存分配介绍" class="headerlink" title="Java内存分配介绍"></a>Java内存分配介绍</h1><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>方法运行时所进入的内存，变量也是在这里</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>new出来的东西会在这块内存中开辟空间并产生地址</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>字节码文件加载时进入的内存</p><h2 id="数组内存分配"><a href="#数组内存分配" class="headerlink" title="数组内存分配"></a>数组内存分配</h2><p>两个数组变量指向同一个数组对象</p><p><img src="https://s3.bmp.ovh/imgs/2022/09/14/d4efd66791b98813.png"></p><h2 id="对象的内存机制"><a href="#对象的内存机制" class="headerlink" title="对象的内存机制"></a>对象的内存机制</h2><p>先将类加载到方法区，对象名加载到栈内存，new对象以后在堆内存开辟空间</p><p><img src="https://s3.bmp.ovh/imgs/2022/09/15/28c07adeceb251d9.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021CCPC广州 C.necklace</title>
      <link href="/archives/12536c1f.html"/>
      <url>/archives/12536c1f.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-necklace"><a href="#C-necklace" class="headerlink" title="C.necklace"></a>C.necklace</h1><p>题目链接：<a href="https://codeforces.com/gym/103415/problem/C">Problem - C - Codeforces</a></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>一串项链有1~n个节点，n和1相连（形成环），其中m个节点是Bob喜欢的，现在给出这m个节点的位置，要求把项链分割成m段，使每段都至少有一个Bob喜欢的节点。求最大段长度最小是多少？</p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>最大值最小我们可以通过二分来求，但如何通过check函数来二分是本题的难点，一般在check函数里都有用到贪心思想，因为只要最优情况满足条件那么当前的mid即为合法答案</p><p>可以想到mid是最大区间长度，而对于一个区间的长度len，在满足小于等于mid和右端点小于下一个Bob喜欢的节点的前提下，右端点要尽可能逼近  下一个特殊节点</p><p><img src="https://s3.bmp.ovh/imgs/2022/09/05/b29718811da38afc.png"></p><p>所以确定了第一个区间的左端点，那么整个区间的划分情况都可以确定了，但是由于是环形，这样使得枚举左端点的时间复杂度很高，而且数据范围很大所以我们应该贪心的优化问题</p><h3 id="贪心优化"><a href="#贪心优化" class="headerlink" title="贪心优化"></a>贪心优化</h3><p>如果我们确定了左端点l，然后得到第一次贪心下的右端点，那么 r-l+1  是在不超过下一个特殊节点下取到的len,</p><p>而且这个len一定小于等于mid，但是这样是不是没有把利益最大化？因为我们明明可以取到mid，只要不超过mid就行，但是在限制下，len取小了，但是换一种思路，我们是不是可以把l前移，在不超过前一个特殊点的情况下前移（同时len也不超过mid），那么这样是不是利益最大化了，因为对于前一段来说，如果仅仅在第一个贪心的思想下，mid满足不了，那么就return false了，但实际上后一段可以为它多“吃”一段，那么可能就会满足条件了</p><p><img src="https://s3.bmp.ovh/imgs/2022/09/05/9fbbb2a2299cd798.png"></p><h3 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a>思路总结</h3><p><img src="https://s3.bmp.ovh/imgs/2022/09/05/f5e6a1078fb785b8.png"></p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">LL a[N];</span><br><span class="line">LL n,m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(LL mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL minv = <span class="number">1e18</span>;</span><br><span class="line">    LL p = a[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">    LL detla = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>;i &lt;= m - <span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p + mid &lt; a[i]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//无法到达右端点</span></span><br><span class="line">        LL d = p + mid - a[i+<span class="number">1</span>] + <span class="number">1</span>;<span class="comment">//可以多利用的长度</span></span><br><span class="line">        <span class="keyword">if</span>(d &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = a[i+<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(detla &lt;= minv)<span class="comment">//只有小于到前一个特殊点的距离才可以</span></span><br><span class="line">            &#123;</span><br><span class="line">                detla += <span class="built_in">min</span>(d,minv - detla);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p = p + mid;<span class="comment">//否则直接后移最大长度</span></span><br><span class="line">        minv = <span class="built_in">min</span>(minv,p-a[i]+detla);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p + mid + detla &gt;= n &amp;&amp; (p + mid + detla) % n &gt;= a[<span class="number">1</span>] - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    LL l = <span class="number">0</span>,r = n;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        LL mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路及图片参考： @gxunWang</p>]]></content>
      
      
      <categories>
          
          <category> CCPC广州 </category>
          
          <category> 2021CCPC广州站网络赛题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
